\providecommand\classopts{}
\expandafter\documentclass\expandafter[table, usenames, svgnames, dvipsnames,14pt, \classopts]{beamer}
\usetheme[everytitleformat=regular,frametitleformat=regular,progressbar=frametitle,numbering=fraction]{m} % load the metropolis theme
\usefonttheme[onlymath]{serif}

\usepackage[portuguese]{babel} % For writing in Portuguese
\usepackage[utf8]{inputenc} % For using unicode characters (easier with accents)
\usepackage{outlines} % For labeled itemize/enumerate blocks
\usepackage{fancybox} % For drawing fancy boxes
\usepackage{ragged2e} % For justifying text
\usepackage{multirow} % For spanning multiple rows in a table
\usepackage{caption}  % For custom captions in tables and figures
\captionsetup{labelformat=empty}

\usepackage{tikz-qtree} % For the graphs
\usetikzlibrary{shapes.arrows,trees,positioning}

\usepackage{stmaryrd} % For some logic symbols
\usepackage{amsmath} % For math symbols
\boldmath

\usepackage{algorithm} % For algorithms...
\usepackage[noend]{algpseudocode} % ...in pseudocode
\usepackage{fixltx2e}
\MakeRobust{\Call} % For allowing nested uses of \Call

\usepackage{tabularx} % For creating tables with data centered in cells
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\title{Diagramas de Decisão Binária (BDDs)}
\subtitle{Aula 2}
\date{7 de outubro de 2015}
\author{Luiz Carlos Vieira}
\institute{MAC0239 - Introdução à Lógica e Verificação de Programas}

% definition symbol
\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

% Image's path
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\graphicspath{{./images/}}

\setbeamerfont{footnote}{size=\tiny}

\definecolor{good}{rgb}{0.14,0.67,0.70} %blueish
\definecolor{bad}{rgb}{0.92,0.30,0.36} % redish
\definecolor{ok}{rgb}{0.97,0.61,0.12} % orangeish
\definecolor{emphasis}{rgb}{0.92,0.00,0.70} % pinkish

\begin{document}
\maketitle

%-------------------------------------------
\begin{frame}{Conteúdo}

    \begin{outline}
        \1 BDDs ordenados e reduzidos (ROBDDs)

        \vspace{1em}
            
        \1 Algoritmos para ROBDDs
            \2[-] algoritmo \texttt{reduzir}
            \2[-] algoritmo \texttt{aplicar}
            \2[-] algoritmo \texttt{restringir}
            \2[-] algoritmo \texttt{existe}
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Relembrando: múltiplas ocorrências}

    \begin{columns}[c]
        \column{0.4\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (x1) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (z1) at (5.5, 4.5) {$r$};
                    \node (x2) at (1.5, 3.0) {$p$};
                    \node (x3) at (6.5, 3.0) {$p$};
                    \node (y2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (x1) to (y1);
                    \draw[thick] (x1) to (z1);
                    \draw[dashed, thick] (y1) to (x2);
                    \draw[thick, bend right=15] (y1) to (1);
                    \draw[thick, emphasis] (x2) to (1);
                    \draw[dashed, thick] (x2) to (0);
                    \draw[thick] (x3) to (1);
                    \draw[dashed, thick] (x3) to (0);
                    \draw[dashed, thick] (z1) to (y2);
                    \draw[thick] (z1) to (x3);
                    \draw[dashed, thick] (y2) to (0);
                    \draw[thick] (y2) to (1);                    

                \end{tikzpicture}

            \end{figure}

        \column{0.6\textwidth}
            
            \begin{outline}
                \small
                \1 A definição de BDDs não impede uma variável de ocorrer mais de uma vez em um caminho
                
                \vspace{1em}
                
                \1 Mas tal representação pode incorrer em desperdícios
                    \2[-] {\scriptsize linha sólida do $p$ à esquerda (colorida) jamais será percorrida}
            \end{outline}
            
            \begin{center}
                \ovalbox{
                    \begin{minipage}[h]{0.9\columnwidth}
                        \noindent\scriptsize\justifying
                        Esse é um resultado comum após as operações discutidas na aula anterior
                    \end{minipage}
                }
            \end{center}

    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Relembrando: comparação de BDDs}

    {\small Além de tornar um BDD menos eficiente, ocorrências múltiplas de uma variável também dificultam a comparação de BDDs}
    
    \begin{columns}[c]
        \column{0.5\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (x1) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (z1) at (5.5, 4.5) {$r$};
                    \node (x2) at (1.5, 3.0) {$p$};
                    \node (x3) at (6.5, 3.0) {$p$};
                    \node (y2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (x1) to (y1);
                    \draw[thick] (x1) to (z1);
                    \draw[dashed, thick] (y1) to (x2);
                    \draw[thick, bend right=15] (y1) to (1);
                    \draw[thick] (x2) to (1);
                    \draw[dashed, thick] (x2) to (0);
                    \draw[thick] (x3) to (1);
                    \draw[dashed, thick] (x3) to (0);
                    \draw[dashed, thick] (z1) to (y2);
                    \draw[thick] (z1) to (x3);
                    \draw[dashed, thick] (y2) to (0);
                    \draw[thick] (y2) to (1);

                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (x) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (y2) at (5.5, 4.5) {$q$};
                    \node (z) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (x) to (y1);
                    \draw[thick] (x) to (y2);
                    \draw[dashed, thick] (y1) to (0);
                    \draw[thick, bend right] (y1) to (1);
                    \draw[dashed, thick] (y2) to (z);
                    \draw[thick] (y2) to (1);
                    \draw[dashed, thick] (z) to (0);
                    \draw[thick] (z) to (1);
                    
                \end{tikzpicture}

            \end{figure}

    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Conceito de ordem de um caminho}

    \begin{columns}[c]
        \column{0.2\textwidth}
        
            \begin{outline}
                \scriptsize
                \uncover<2->{
                    \1 $[p\uncover<3->{,q}\uncover<4->{,p}]$
                }
                \uncover<5->{
                    \1 $[p\uncover<6->{,q}]$
                }
                \uncover<7->{
                    \1 $[p\uncover<8->{,r}\uncover<9->{,q}]$
                }
                \uncover<10->{
                    \1 $[p\uncover<11->{,r}\uncover<12->{,p}]$
                }
            \end{outline}
                
        \column{0.4\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p1) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (r1) at (5.5, 4.5) {$r$};
                    \node (p2) at (1.5, 3.0) {$p$};
                    \node (p3) at (6.5, 3.0) {$p$};
                    \node (q2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (p1) to (q1);
                    \draw[thick] (p1) to (r1);
                    \draw[dashed, thick] (q1) to (p2);
                    \draw[thick, bend right=15] (q1) to (1);
                    \draw[thick] (p2) to (1);
                    \draw[dashed, thick] (p2) to (0);
                    \draw[thick] (p3) to (1);
                    \draw[dashed, thick] (p3) to (0);
                    \draw[dashed, thick] (r1) to (q2);
                    \draw[thick] (r1) to (p3);
                    \draw[dashed, thick] (q2) to (0);
                    \draw[thick] (q2) to (1);

                    \uncover<2-4>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<3-4>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p1) to (q1);
                    }
                    \uncover<4-4>{
                        \node[emphasis] (p2) at (1.5, 3.0) {$p$};
                        \draw[dashed, thick, emphasis] (q1) to (p2);
                        \draw[thick, emphasis] (p2) to (1);
                        \draw[dashed, thick, emphasis] (p2) to (0);
                    }
                    
                    \uncover<5-6>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<6-6>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p1) to (q1);
                        \draw[thick, bend right=15, emphasis] (q1) to (1);
                    }
                    
                    \uncover<7-9>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<8-9>{
                        \node[emphasis] (r1) at (5.5, 4.5) {$r$};
                        \draw[thick, emphasis] (p1) to (r1);
                    }
                    \uncover<9-9>{
                        \node[emphasis] (q2) at (4.3, 3.0) {$q$};
                        \draw[dashed, thick, emphasis] (r1) to (q2);
                        \draw[dashed, thick, emphasis] (q2) to (0);
                        \draw[thick, emphasis] (q2) to (1);
                    }

                    \uncover<10-12>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<11-12>{
                        \node[emphasis] (r1) at (5.5, 4.5) {$r$};
                        \draw[thick, emphasis] (p1) to (r1);
                    }
                    \uncover<12-12>{
                        \node[emphasis] (p3) at (6.5, 3.0) {$p$};
                        \draw[thick, emphasis] (r1) to (p3);
                        \draw[thick, emphasis] (p3) to (1);
                        \draw[dashed, thick, emphasis] (p3) to (0);
                    }
                \end{tikzpicture}

            \end{figure}

        \column{0.2\textwidth}
        
            \begin{outline}
                \scriptsize
                \uncover<13->{
                    \1 $[p\uncover<14->{,q}]$
                }
                \uncover<15->{
                    \1 $[p\uncover<16->{,q}\uncover<17->{,r}]$
                }
                \uncover<18->{
                    \1 $[p\uncover<19->{,q}]$
                }
            \end{outline}
            
        \column{0.2\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                    \uncover<13-14>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<14-14>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p) to (q1);
                        \draw[dashed, thick, emphasis] (q1) to (0);
                        \draw[thick, bend right, emphasis] (q1) to (1);
                    }
                    
                    \uncover<15-17>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<16-17>{
                        \node[emphasis] (q2) at (5.5, 4.5) {$q$};
                        \draw[thick, emphasis] (p) to (q2);
                    }
                    \uncover<17-17>{
                        \node[emphasis] (r) at (4.0, 3.0) {$r$};
                        \draw[dashed, thick, emphasis] (q2) to (r);
                        \draw[dashed, thick, emphasis] (r) to (0);
                        \draw[thick, emphasis] (r) to (1);
                    }
                    
                    \uncover<18-18>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<19-19>{
                        \node[emphasis] (q2) at (5.5, 4.5) {$q$};
                        \draw[thick, emphasis] (q2) to (1);
                    }
                    
                \end{tikzpicture}

            \end{figure}

    \end{columns}

    \vspace{1em}
    
    \only<20>{
        \begin{columns}[c]
            \column{0.6\textwidth}
                \ovalbox{
                    \begin{minipage}[h]{0.8\columnwidth}
                        \noindent\scriptsize
                        Ocorrem repetições e não há um padrão na ordenação
                    \end{minipage}
                }            
            
            \column{0.4\textwidth}
                \ovalbox{
                    \begin{minipage}[h]{0.8\columnwidth}
                        \noindent\scriptsize
                        Não ocorrem repetições e há um padrão na ordenação
                    \end{minipage}
                }            
        \end{columns}
    }
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{BDDs ordenados}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Quando a ordem das variáveis em qualquer caminho é sempre a mesma, o BDD passa a ser chamado Diagrama de Busca Binária Ordenado (OBDD)
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: OBDDs}

    \begin{block}{\textbf{Definição 6.6}}
        Seja $[p_1,p_2,...,p_n]$ uma lista ordenada de variáveis sem duplicação e seja $B$ um BDD tal que todas as suas variáveis aparecem em algum lugar da lista. Dizemos que $B$ tem a ordem $[p_1,p_2,...,p_n]$ se todos os nós de variáveis de $B$ ocorrem na lista, e, para toda ocorrência de $p_i$ seguido de $p_j$ ao longo de qualquer caminho em $B$ temos $i < j$.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplo de BDD ordenado}

    \begin{figure}
    
        \caption{Ordem: $[p, q, r]$}
    
        \begin{tikzpicture}
            [scale=1.0,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (8,6);

            \node (p) at (3.0, 5.5)  {$p$};
            \node (q1) at (1.5, 4.0)  {$q$};
            \node (q2) at (4.5, 4.0)  {$q$};
            
            \node (r1) at (0.6, 2.5)  {$r$};
            \node (r2) at (2.4, 2.5)  {$r$};
            \node (r3) at (3.6, 2.5)  {$r$};
            \node (r4) at (5.4, 2.5)  {$r$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.5) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.5) {$1$};

            \draw[dashed, thick] (p) to (q1);
            \draw[thick] (p) to (q2);
            \draw[dashed, thick] (q1) to (r1);
            \draw[thick] (q1) to (r2);
            \draw[dashed, thick] (q2) to (r3);
            \draw[thick] (q2) to (r4);
            
            \draw[dashed, thick] (r1) to (0);
            \draw[thick] (r1) to (1);
            \draw[dashed, thick] (r2) to (0);
            \draw[thick] (r2) to (1);
            \draw[dashed, thick] (r3) to (0);
            \draw[thick] (r3) to (1);
            \draw[thick] (r4) to (0);
            \draw[dashed, thick] (r4) to (1);            
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------
    
%-------------------------------------------
\begin{frame}{Exemplo de BDD não ordenado}

    \begin{figure}
    
        \caption{Não ordenado ($[p, q, r]$ à esquerda e $[p, r, q]$ à direita)}
    
        \begin{tikzpicture}
            [scale=1.0,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (8,6);

            \node (p) at (3.0, 5.5)  {$p$};
            \node (q1) at (1.5, 4.0)  {$q$};
            \node (r1) at (4.5, 4.0)  {$r$};
            
            \node (r2) at (0.6, 2.5)  {$r$};
            \node (q2) at (5.4, 2.5)  {$q$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.5) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.5) {$1$};

            \draw[dashed, thick] (p) to (q1);
            \draw[thick] (p) to (r1);
            \draw[dashed, thick] (q1) to (r2);
            \draw[thick] (q1) to (1);
            \draw[dashed, thick] (r1) to (1);
            \draw[thick] (r1) to (q2);
            \draw[dashed, thick] (r2) to (0);
            \draw[thick] (r2) to (1);
            \draw[dashed, thick] (q2) to (0);
            \draw[thick] (q2) to (1);
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Vantagens da ordenação de BDDs}

    \begin{outline}
        \1 A comparação de dois OBDDs de ordens compatíveis é imediata
            \2[-] basta verificar se suas estruturas são idênticas
        
        \vspace{1em}
        
        \1 Aplicações das reduções C1-C3 em um OBDD garantidamente mantêm a ordem original
        
        \vspace{1em}
        
        \1 O compromisso com a ordem produz uma representação única de funções booleanas
            \2[-] chamada de \textit{forma canônica}
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{OBDDs reduzidos}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                OBDDs reduzidos são, por sua vez, chamados de Diagramas de Busca Binária Ordenados Reduzidos (ROBDD)
            \end{minipage}
        }
    \end{center}            

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Teorema: ROBDDs são únicos}

    \begin{block}{\textbf{Teorema 6.7}}
        A representação em ROBDD de uma função dada $\phi$ é unica. Isto é, sejam $B$ e $B^\prime$ dois ROBDDs com ordens compatíveis. Se $B$ e $B^\prime$ representam a mesma função booleana, então eles têm estruturas idênticas.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Características de ROBDDs}

    \begin{outline}
        \1 RODDBs permitem representações compactas de certas classes de funções booleanas
            \2[-] que seriam exponenciais em outros formatos/representações
            
        \vspace{1em}
        
        \1 Por outro lado, as operações $\land$ e $\lor$ apresentadas anteriormente não funcionam
            \2[-] pois introduzem ocorrências múltiplas de uma mesma variável
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Impacto da escolha da ordenação}

    Considere a escolha da ordem de variáveis para a seguinte função booleana em CNF:
    $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land ... \land (p_{2n-1} \lor p_{2n})$

    \begin{outline}
        \small
        \1 Se a escolha for a ``\textit{ordem natural de ocorrência na fórmula}'' ($[p_1,p_2,p_3,...,,p_{2n-1},p_{2n}]$), o ROBDD terá $2n+2$ nós
        
        \vspace{1em}
        
        \1 Se a escolha for ``\textit{índices impares antes de índices pares}'' ($[p_1,p_3,p_5,...,p_{2n-1},p_2,p_4,p_6,...,p{2n}]$), o ROBDD terá $2^{n+1}$ nós
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ordem ``natural'' para $n=3$}
    
    \scriptsize
    ROBDD para $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land (p_5 \land p_6)$ com a ordem de variáveis $[p_1,p_2,p_3,p_4,p_5,p_6]$
    
    \begin{figure}
    
        \begin{tikzpicture}
            [scale=0.9,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines, step=0.5] (0,0) grid (5,6);

            \node[rectangle, scale=0.7] (0) at (0.0, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (5.0, 0.0) {$1$};
            
            \node (p6) at (2.5, 1.0) {$p_6$};
            \node (p5) at (5.0, 2.0) {$p_5$};
            \node (p4) at (2.5, 3.0) {$p_4$};
            \node (p3) at (5.0, 4.0) {$p_3$};
            \node (p2) at (2.5, 5.0) {$p_2$};
            \node (p1) at (5.0, 6.0) {$p_1$};

            \draw[dashed, thick] (p1) to (p2);
            \draw[thick] (p1) to (p3);
            \draw[dashed, thick] (p2) to (0);
            \draw[thick] (p2) to (p3);
            \draw[dashed, thick] (p3) to (p4);
            \draw[thick] (p3) to (p5);
            \draw[dashed, thick] (p4) to (0);
            \draw[thick] (p4) to (p5);
            \draw[dashed, thick] (p5) to (p6);
            \draw[thick] (p5) to (1);
            \draw[dashed, thick] (p6) to (0);
            \draw[thick] (p6) to (1);
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ordem ``ímpar/par'' para $n=3$}

    \scriptsize
    ROBDD para $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land (p_5 \land p_6)$ com a ordem de variáveis $[p_1,p_3,p_5,p_2,p_4,p_6]$
    
    \begin{figure}
    
        \begin{tikzpicture}
            [scale=0.8,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines, step=0.5] (0,0) grid (6,7);

            \node[rectangle, scale=0.7] (0) at (0.5, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (6.0, 0.0) {$1$};
            
            \node (p1) at (3.25, 6.5) {$p_1$};
            \node (p3a) at (1.5, 5.5) {$p_3$};
            \node (p3b) at (5.0, 5.5) {$p_3$};
            \node (p5a) at (0.5, 4.5) {$p_5$};
            \node (p5b) at (2.5, 4.5) {$p_5$};
            \node (p5c) at (4.0, 4.5) {$p_5$};
            \node (p5d) at (6.0, 4.5) {$p_5$};
            \node (p2a) at (0.0, 3.3) {$p_2$};
            \node (p2b) at (1.0, 3.3) {$p_2$};
            \node (p2c) at (2.0, 3.3) {$p_2$};
            \node (p2d) at (3.0, 3.3) {$p_2$};
            \node (p4a) at (2.85, 1.7) {$p_4$};
            \node (p4b) at (5.25, 1.7) {$p_4$};
            \node (p6) at (4.0, 0.7)  {$p_6$};
            
            \draw[dashed, thick] (p1) to (p3a);
            \draw[thick] (p1) to (p3b);
            \draw[dashed, thick] (p3a) to (p5a);
            \draw[thick] (p3a) to (p5b);
            \draw[dashed, thick] (p3b) to (p5c);
            \draw[thick] (p3b) to (p5d);
            \draw[dashed, thick] (p5a) to (p2a);
            \draw[thick] (p4a) to (p6);
            \draw[dashed, thick] (p4b) to (0);
            \draw[thick] (p4b) to (1);
            \draw[thick] (p5a) to (p2b);
            \draw[dashed, thick] (p5b) to (p2c);
            \draw[thick] (p5b) to (p2d);
            \draw[dashed, thick, bend left=10] (p5c) to (p4a);
            \draw[thick] (p5c) to (p4b);
            \draw[dashed, thick, bend right=10] (p5d) to (p6);
            \draw[thick] (p5d) to (1);
            \draw[dashed, thick] (p4a) to (0);
            \draw[dashed, thick] (p6) to (0);
            \draw[thick] (p6) to (1);
            
            \draw[dashed, thick] (p2a) to (0);
            \draw[thick] (p2a) to (p4a);
            \draw[dashed, thick] (p2b) to (0);
            \draw[thick, bend right=10] (p2b) to (p4b);
            \draw[dashed, thick] (p2c) to (0);
            \draw[thick, bend left=10] (p2c) to (p6);
            \draw[dashed, thick] (p2d) to (0);
            \draw[thick] (p2d) to (1);
            
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Escolha da ordenação}

    \begin{outline}
        \1 A sensibilidade do tamanho de um ROBDD à ordem escolhida é um preço que se paga pelas vantagens obtidas
        
        \vspace{1em}
        
        \1 Encontrar a ordem ótima também é um problema computacional caro
            \2[-] mas há heurísticas que produzem ordens razoavelmente boas
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Importância da representação canônica}

    \scriptsize

    \begin{outline}
        \uncover<1->{
            \1 \textbf{Ausência de variáveis redundantes}. Se o valor de uma função booleana não depende de uma variável, então nenhum ROBDD que a represente contém tal variável;
        }
        
        \uncover<2->{
            \vspace{1em}
            
            \1 \textbf{Teste de equivalência semântica}. Se duas funções são representadas por OBDDs com ordens compatíveis, é possível decidir eficientemente se são equivalentes reduzindo seus OBDDs e comparando sua estrutura;
        }
        
        \uncover<3->{
            \vspace{1em}
            
            \1 \textbf{Teste de validade}. Se uma função booleana é válida, seu ROBDD é igual a $B_1$;
        }
        
        \uncover<4->{
            \vspace{1em}
            
            \1 \textbf{Teste de satisfação}. Se uma função booleana é satisfeita, então seu ROBDD não é igual a $B_0$.
        }
        
        \uncover<5->{
            \vspace{1em}

            \1 \textbf{Teste de implicação}. Pode-se testar se uma função $\phi$ implica em outra $\psi$ calculando o ROBDD para $\phi \land \psi$ -- a implicação é verdadeira se e somente este ROBDD é igual a $B_0$;
        }
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Antes de prosseguir...}

    Antes de estudarmos as operações sobre ROBDDs, é necessário estudar um conceito importantíssimo: a \textit{expansão de Shannon}

\end{frame}
%-------------------------------------------


%-------------------------------------------
\begin{frame}{Definição: restrições de Shannon}

    \begin{block}{\textbf{Definição 6.9}}
        Sejam $\phi$ uma expressão booleana e $p$ uma variável. Denotamos por $\phi[0/p]$ a expressão booleana obtida substituindo-se todas as ocorrências de $p$ em $\phi$ por $0$. A expressão $\phi[1/p]$ é definida de maneira semelhante. As expressões $\phi[0/p]$ e $\phi[1/p]$ são chamadas de restrições de Shannon em $\phi$ com relação à variável $p$.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplos de restrições}

    Para $\phi \equiv p \land (q \lor \lnot{p})$ tem-se:

    \begin{outline}
        \1 $\phi[0/p]$ é igual a $0 \land (q \lor \lnot{0})$
            \2[-] que é semanticamente equivalente a $0$
            
        \vspace{1em}
        
        \1 $\phi[1/p]$ é igual a $1 \land (q \lor \lnot{1})$
            \2[-] que é semanticamente equivalente a $q$
            
        \vspace{1em}
        
        \1 $\phi[0/q]$ é igual a $p \land (0 \lor \lnot{p})$
            \2[-] que é semanticamente equivalente a $\bot$
            
        \vspace{1em}
        
        \1 $\phi[1/q]$ é igual a $p \land (1 \lor \lnot{p})$
            \2[-] que é semanticamente equivalente a $p$
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Uso das restrições}

    \begin{outline}
        \1 As restrições permitem executar recorrências em expressões booleanas decompondo-as em expressões mais simples
        
        \vspace{1em}
        
        \1 Se $p$ é uma variável em $\phi$, então $\phi$ é equivalente a $\lnot{p} \land \phi[0/p] \lor p \land \phi[1/p]$
            \2[-] facilmente verificável
            \2[-] fazendo $p = 0$ resulta em $\phi[0/p]$
            \2[-] fazendo $p = 1$ resulta em $\phi[1/p]$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Lema: expansão de Shannon}

    \begin{block}{\textbf{Lema 6.10}}
        Para todas as expressões booleanas $\phi$ e todas as variáveis $p$ (mesmo as que não ocorrem em $\phi$), tem-se a chamada \textit{expansão de Shannon}:\\[1em]
        $\phi \equiv \lnot{p} \land \phi[0/p] \lor p \land \phi[1/p]$
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{operador \textproc{ite}}

    \begin{block}{\textbf{Definição auxiliar\footnote{não consta do livro}}}
        Com base nessa equivalência, definimos o operador \textproc{ite} (de \textit{if-then-else}) como:\\[1em]
        $\textproc{ite}(p,\phi,\phi^{\prime}) = (p \land \phi) \lor (\lnot{p} \land \phi^{\prime})$
        \\[1em]
        Dessa forma, \textproc{ite} é verdadeiro se a variável $p$ e a expressão $\phi$ são verdadeiros, ou se a variável $p$ é falsa e a expressão $\phi^{\prime}$ é verdadeira.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Uso do operador \textproc{ite}}

    O operador $\textproc{ite}(p,\phi,\phi^{\prime}) = (p \land \phi) \lor (\lnot{p} \land \phi^{\prime})$ permite expressar qualquer operador da gramática da Lógica Proposicional:

    \small
    \begin{outline}
        \1 $\lnot{p} = \textproc{ite}(\textcolor{emphasis}{p},\lnot{\textcolor{emphasis}{1}},\lnot{\textcolor{emphasis}{0}}) = \textproc{ite}(p,0,1)$
        
        \1 $p \land q = \textproc{ite}(\textcolor{emphasis}{p},\textcolor{emphasis}{1} \land q,\textcolor{emphasis}{0} \land q) = \textproc{ite}(p,q,0) = \textproc{ite}(p,\textproc{ite}(\textcolor{emphasis}{q},\textcolor{emphasis}{1},\textcolor{emphasis}{0}),0)$
        
        \1 $p \lor q = \textproc{ite}(\textcolor{emphasis}{p},\textcolor{emphasis}{1} \lor q,\textcolor{emphasis}{0} \lor q) = \textproc{ite}(p,1,q) = \textproc{ite}(p,1,\textproc{ite}(\textcolor{emphasis}{q},\textcolor{emphasis}{1},\textcolor{emphasis}{0}))$
        
        \1 $p \to q = \textproc{ite}(\textcolor{emphasis}{p},\textcolor{emphasis}{1} \to q,\textcolor{emphasis}{0} \to q) = \textproc{ite}(p,q,1) = \textproc{ite}(p,\textproc{ite}(\textcolor{emphasis}{q},\textcolor{emphasis}{1},\textcolor{emphasis}{0}),1)$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Forma normal condicional}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Uma expressão booleana está na forma normal condicional se e somente se ela contém apenas constantes, o operador condicional \textproc{ite} e variáveis sendo testadas por esse operador
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplos na forma e fora dela}

    \small
    \begin{outline}
        \1 A expressão $\textproc{ite}(p, \textproc{ite}(q, 1, \textcolor{emphasis}{r}), \textproc{ite}(q, 1, 0))$ \underline{não está} na forma normal condicional
            \2[-] a variável $\textcolor{emphasis}{r}$ ainda não está sendo testada condicionalmente

        \vspace{1em}
            
        \1 A expressão $\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(r, 1, 0)), \textproc{ite}(q, 1, 0))$ \underline{está} na forma normal condicional        
            \2[-] todas as variáveis estão sendo testadas condicionalmente
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Conversão para a forma condicional}

    Toda expressão booleana pode ser convertida indutivamente para a forma normal condicional da seguinte maneira:

    \begin{outline}
        \1 Se $\phi$ só contém variáveis de teste, ela já está na forma normal condicional
        
        \vspace{1em}
        
        \1 Senão, enquanto houver uma variável $p \in \phi$ que não seja teste, reescreva $\phi$ como $\textproc{ite}(p, \phi[1/p], \phi[0/p])$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Por exemplo}

    \begin{outline}
        \0 Conversão de $(p \lor q) \land (q \lor r)$ para a forma normal conditional
        \1[=] $\textproc{ite}(\textcolor{emphasis}{p}, (\textcolor{emphasis}{1} \lor q) \land (q \lor r), (\textcolor{emphasis}{0} \lor q) \land (q \lor r))$
        \1[=] $\textproc{ite}(p, q \lor r, q)$
        \1[=] $\textproc{ite}(p, \textproc{ite}(\textcolor{emphasis}{q}, \textcolor{emphasis}{1} \lor r, \textcolor{emphasis}{0} \lor r), \textproc{ite}(\textcolor{emphasis}{q}, \textcolor{emphasis}{1}, \textcolor{emphasis}{0}))$
        \1[=] $\textproc{ite}(p, \textproc{ite}(q, 1, r), \textproc{ite}(q, 1, 0))$
        \1[=] $\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(\textcolor{emphasis}{r}, \textcolor{emphasis}{1}, \textcolor{emphasis}{0})), \textproc{ite}(q, 1, 0))$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Forma condicional e árvore de decisão}

    A estrutura de recorrência da forma normal condicional:
    $$\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(r, 1, 0)), \textproc{ite}(q, 1, 0))$$
    da expressão booleana $(p \lor q) \land (q \lor r)$ é a mesma da sua arvore de decisão binária

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração do argumento anterior}
    
    \begin{columns}[c]
        \column{0.5\textwidth}

            \begin{figure}
            
                \caption{\scriptsize Árvore de Decisão Binária da expressão: $(p \lor q) \land (q \lor r)$}
                
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (p) at (4.25, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (6.0, 4.5) {$q$};
                    \node[rectangle, scale=0.7] (1a) at (1.5, 3.0) {$1$};
                    \node (r) at (3.5, 2.0) {$r$};
                    \node[rectangle, scale=0.7] (1b) at (5.0, 3.0) {$1$};
                    \node[rectangle, scale=0.7] (0a) at (7.0, 3.0) {$0$};
                    \node[rectangle, scale=0.7] (1c) at (2.5, 0.0) {$1$};
                    \node[rectangle, scale=0.7] (0b) at (4.5, 0.0) {$0$};

                    \draw[thick] (p) to (q1);
                    \draw[dashed, thick] (p) to (q2);
                    \draw[thick] (q1) to (1a);
                    \draw[dashed, thick] (q1) to (r);
                    \draw[thick] (q2) to (1b);
                    \draw[dashed, thick] (q2) to (0a);
                    \draw[thick] (r) to (1c);
                    \draw[dashed, thick] (r) to (0b);
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \begin{figure}
            
                \caption{\scriptsize Estrutura recorrente da forma condicional: $\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(r, 1, 0)), \textproc{ite}(q, 1, 0))$}
            
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={minimum height=4mm, draw=none, align=center, text depth = 0pt, transform shape}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (p) at (4.25, 6.0) {$\textproc{ite}(p,\phi,\phi^{\prime})$};
                    \node (q1) at (2.5, 4.5) {$\textproc{ite}(q,\phi,\phi^{\prime})$};
                    \node (q2) at (6.0, 4.5) {$\textproc{ite}(q,\phi,\phi^{\prime})$};
                    \node[rectangle, scale=0.7] (1a) at (1.5, 3.0) {$1$};
                    \node (r) at (3.5, 2.0) {$\textproc{ite}(r,\phi,\phi^{\prime})$};
                    \node[rectangle, scale=0.7] (1b) at (5.0, 3.0) {$1$};
                    \node[rectangle, scale=0.7] (0a) at (7.0, 3.0) {$0$};
                    \node[rectangle, scale=0.7] (1c) at (2.5, 0.0) {$1$};
                    \node[rectangle, scale=0.7] (0b) at (4.5, 0.0) {$0$};

                    \draw[dotted, thick] (p) -- (q1) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (p) -- (q2) node[midway, scale=0.5] {$\phi^{\prime}$};
                    \draw[dotted, thick] (q1) -- (1a) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (q1) -- (r) node[midway, scale=0.5] {$\phi^{\prime}$};
                    \draw[dotted, thick] (q2) -- (1b) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (q2) -- (0a) node[midway, scale=0.5] {$\phi^{\prime}$};
                    \draw[dotted, thick] (r) -- (1c) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (r) -- (0b) node[midway, scale=0.5] {$\phi^{\prime}$};
                \end{tikzpicture}

            \end{figure}        
        
    \end{columns}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Estrutura de dados}

    A estrutura de dados para representar um ROBDD é composta de:

    \begin{outline}
        \1 Uma tabela $T: n \mapsto \langle v,t,f \rangle$
            \2[-] que associa a cada identificador $n$ um nó com variável de teste $v$, filho esquerdo $t$ e filho direito $f$
        
        \vspace{1em}
        
        \1 Uma tabela inversa $T^{-1}: \langle v,t,f \rangle \mapsto n$
            \2[-] que associa nós em identificadores
            \2[-] devido ao compartilhamento de sub-grafos
            \2[-] usada para garantir que os diagramas sejam reduzidos
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração dessa estrutura de dados}

    \setlength{\tabcolsep}{2pt}
    \renewcommand{\arraystretch}{1.5}        

    \begin{columns}[c]

        \column{0.2\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                \end{tikzpicture}

            \end{figure}

        \column{0.35\textwidth}
        
            \begin{table}
                \scriptsize
                \caption{\scriptsize Tabela $T: n \mapsto \langle v,t,f \rangle$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    $0$ & $\langle p_{6},\textproc{null},\textproc{null} \rangle$\\
                    $1$ & $\langle p_{6},\textproc{null},\textproc{null} \rangle$\\
                    $2$ & $\langle p,3,4 \rangle$\\
                    $3$ & $\langle q,0,1 \rangle$\\
                    $4$ & $\langle q,5,1 \rangle$\\
                    $5$ & $\langle r,0,1 \rangle$\\
                \end{tabular}
            \end{table}

        \column{0.45\textwidth}
        
            \begin{table}
                \scriptsize
                \caption{\scriptsize Tabela $T^{-1}: \langle v,t,f \rangle \mapsto n$}
                \begin{tabular}{c|c}
                    $\langle v,t,f \rangle$ & $T^{-1}(\langle v,t,f \rangle)$\\
                    \hline
                    $\langle p_{6},\textproc{null},\textproc{null} \rangle$ & $0$\\
                    $\langle p_{6},\textproc{null},\textproc{null} \rangle$ & $1$\\
                    $\langle p,3,4 \rangle$                               & $2$\\
                    $\langle q,0,1 \rangle$                               & $3$\\
                    $\langle q,5,1 \rangle$                               & $4$\\
                    $\langle r,0,1 \rangle$                               & $5$\\
                \end{tabular}
            \end{table}
            
    \end{columns}

    \vspace{-1em}
    
    \begin{center}
        \ovalbox{
            \begin{minipage}[h]{\columnwidth}
                \noindent\scriptsize\justifying
                $p_6$: variável auxiliar usada nos nós terminais para manter a uniformidade da tabela
            \end{minipage}
        }
    \end{center}    
    
\end{frame}
%-------------------------------------------
    
%-------------------------------------------
\begin{frame}{Observações}

    Nos algoritmos estudados a seguir, assume-se que:

    \begin{outline}
        \1 $T(n) = T^{-1}(\langle v,t,f \rangle) = \textproc{null}$ sempre que $(n, \langle v,t,f \rangle) \notin T$
        
        \vspace{1em}
        
        \1 A tabela $T$ é uma variável global e $|T|$ é o número de entradas existentes nessa tabela
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de inicialização}

    Cria a tabela $T$ de um ROBDD. Funciona assim:

    \small
    \begin{outline}
        \1 Recebe uma entrada $m$ indicando o número máximo de variáveis existentes na expressão booleana
        
        \vspace{1em}
        
        \1 Inicia a tabela $T$ com duas tuplas especiais
            \2[-] representando os nós terminais $0$ e $1$
            \2[-] para garantir uniformidade, associa os nós terminais à uma variável auxiliar $p_{m+1}$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{INIT}}
    %\scriptsize
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \Procedure{INIT}{$T,m$}
                \State $T \gets \{(0, \langle m+1, \textproc{null},\textproc{null} \rangle\}),$\par
                \hskip\algorithmicindent $\{(1, \langle m+1, \textproc{null}, \textproc{null} \rangle\})$
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de inserção de nós}

    Insere um nó em um ROBDD, mantendo-o reduzido e ordenado. Funciona assim:

    \small
    \begin{outline}
        \1 Recebe como entrada uma variável $v$ e os identificadores de seus filhos $t$ e $f$

        \vspace{0.5em}

        \1 Se o nó $v$ for redundante ($t = f$), devolve imediatamente o identificador do nó filho ($t$)

        \vspace{0.5em}
        
        \1 Caso o nó $v$ já tenha sido criado, devolve seu identificador
        
        \vspace{0.5em}
        
        \1 Caso o nó $v$ seja novo, cria-o e devolve o identificador
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \texttt{INS}}
    \scriptsize
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \Function{INS}{$T,v,t,f$}
                \If{$t = f$}
                    \State \Return $t$
                \EndIf
                \State $n \gets T^{-1}(\langle v,t,f \rangle)$
                \If{$n = \textproc{null}$}
                    \State $n \gets |T|$
                    \State $T \gets T \cup \{(n, \langle v, t, f \rangle)\}$
                \EndIf
                \State \Return $n$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de construção de ROBDDs}

    Constrói um ROBDD a partir de uma expressão em forma normal condicional. Funciona assim:

    \small
    \begin{outline}
        \1 Recebe como entrada uma variável $v$ e os identificadores de seus filhos $t$ e $f$

        \vspace{0.5em}

        \1 Se o nó $v$ for redundante ($t = f$), devolve imediatamente o identificador do nó filho ($t$)

        \vspace{0.5em}
        
        \1 Caso o nó $v$ já tenha sido criado, devolve seu identificador
        
        \vspace{0.5em}
        
        \1 Caso o nó $v$ seja novo, cria-o e devolve o identificador
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \texttt{BUILD}}
    \scriptsize
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \Function{BUILD}{$\textproc{ite}(v,\phi_{t},\phi_{f})$}
                \If{$\phi_{t},\phi_{f} \in \{0,1\}$}
                    \State \Return $\Call{INS}{v,\phi_{t},\phi_{f}}$
                \EndIf
                \If{$\phi_{f} \in \{0,1\}$}
                    \State \Return $\Call{INS}{v,\Call{BUILD}{\phi_{t}},\phi_{f}}$
                \EndIf
                \If{$\phi_{t} \in \{0,1\}$}
                    \State \Return $\Call{INS}{v,\phi_{t},\Call{BUILD}{\phi_{f}}}$
                \EndIf
                \State \Return $\Call{INS}{v,\Call{BUILD}{\phi_{t}},\Call{BUILD}{\phi_{f}}}$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
%\begin{frame}{Algoritmo \texttt{reduzir}}


%\end{frame}
%-------------------------------------------

%-------------------------------------------
%\begin{frame}{Algoritmo \texttt{aplicar}}


%\end{frame}
%-------------------------------------------

%-------------------------------------------
%\begin{frame}{Algoritmo \texttt{restringir}}


%\end{frame}
%-------------------------------------------

%-------------------------------------------
%\begin{frame}{Algoritmo \texttt{existe}}


%\end{frame}
%-------------------------------------------

\end{document}