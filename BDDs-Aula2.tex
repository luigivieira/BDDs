\providecommand\classopts{}
\expandafter\documentclass\expandafter[table, usenames, svgnames, dvipsnames,14pt, \classopts]{beamer}
\usetheme[everytitleformat=regular,frametitleformat=regular,progressbar=frametitle,numbering=fraction]{m} % load the metropolis theme
\usefonttheme[onlymath]{serif}

\usepackage[portuguese]{babel} % For writing in Portuguese
\usepackage[utf8]{inputenc} % For using unicode characters (easier with accents)
\usepackage{outlines} % For labeled itemize/enumerate blocks
\usepackage{fancybox} % For drawing fancy boxes
\usepackage{ragged2e} % For justifying text
\usepackage{multirow} % For spanning multiple rows in a table
\usepackage{caption}  % For custom captions in tables and figures
\captionsetup{labelformat=empty}

\usepackage{tikz-qtree} % For the graphs
\usetikzlibrary{shapes.arrows,trees,positioning}

\usepackage{stmaryrd} % For some logic symbols
\usepackage{amsmath} % For math symbols
\boldmath

\usepackage{algorithm} % For algorithms...
\usepackage[noend]{algpseudocode} % ...in pseudocode
\usepackage{fixltx2e}
\MakeRobust{\Call} % For allowing nested uses of \Call

\usepackage{tabularx} % For creating tables with data centered in cells
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\title{Diagramas de Decisão Binária (BDDs)}
\subtitle{Aula 2}
\date{7 de outubro de 2015}
\author{Luiz Carlos Vieira}
\institute{MAC0239 - Introdução à Lógica e Verificação de Programas}

% definition symbol
\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

% Image's path
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\graphicspath{{./images/}}

\setbeamerfont{footnote}{size=\tiny}

\definecolor{good}{rgb}{0.14,0.67,0.70} %blueish
\definecolor{bad}{rgb}{0.92,0.30,0.36} % redish
\definecolor{ok}{rgb}{0.97,0.61,0.12} % orangeish
\definecolor{emphasis}{rgb}{0.92,0.00,0.70} % pinkish

% Tradução dos comandos de algoritmos
\algrenewcommand\algorithmicfunction{\textbf{função}}
\algrenewcommand\algorithmicprocedure{\textbf{procedimento}}
\algrenewcommand\algorithmicend{\textbf{fim}}
\algrenewcommand\algorithmicif{\textbf{se}}
\algrenewcommand\algorithmicthen{\textbf{então}}
\algrenewcommand\algorithmicreturn{\textbf{devolva}}
\algrenewcommand\algorithmicrequire{\textbf{precondição:}}
\algrenewcommand\algorithmicensure{\textbf{pós-condição:}}

\algrenewcommand\alglinenumber[1]{\tiny #1:}

\begin{document}
\maketitle

%-------------------------------------------
\begin{frame}{Conteúdo}

    \begin{outline}
        \1 BDDs ordenados e reduzidos (ROBDDs)

        \vspace{1em}
            
        \1 Algoritmos para ROBDDs
            \2[-] algoritmo \texttt{reduzir}
            \2[-] algoritmo \texttt{aplicar}
            \2[-] algoritmo \texttt{restringir}
            \2[-] algoritmo \texttt{existe}
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Relembrando: múltiplas ocorrências}

    \begin{columns}[c]
        \column{0.4\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (x1) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (z1) at (5.5, 4.5) {$r$};
                    \node (x2) at (1.5, 3.0) {$p$};
                    \node (x3) at (6.5, 3.0) {$p$};
                    \node (y2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (x1) to (y1);
                    \draw[thick] (x1) to (z1);
                    \draw[dashed, thick] (y1) to (x2);
                    \draw[thick, bend right=15] (y1) to (1);
                    \draw[thick, emphasis] (x2) to (1);
                    \draw[dashed, thick] (x2) to (0);
                    \draw[thick] (x3) to (1);
                    \draw[dashed, thick] (x3) to (0);
                    \draw[dashed, thick] (z1) to (y2);
                    \draw[thick] (z1) to (x3);
                    \draw[dashed, thick] (y2) to (0);
                    \draw[thick] (y2) to (1);                    

                \end{tikzpicture}

            \end{figure}

        \column{0.6\textwidth}
            
            \begin{outline}
                \small
                \1 A definição de BDDs não impede uma variável de ocorrer mais de uma vez em um caminho
                
                \vspace{1em}
                
                \1 Mas tal representação pode incorrer em desperdícios
                    \2[-] {\scriptsize linha sólida do $p$ à esquerda (colorida) jamais será percorrida}
            \end{outline}
            
            \begin{center}
                \ovalbox{
                    \begin{minipage}[h]{0.9\columnwidth}
                        \noindent\scriptsize\justifying
                        Esse é um resultado comum após as operações discutidas na aula anterior
                    \end{minipage}
                }
            \end{center}

    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Relembrando: comparação de BDDs}

    {\small Além de tornar um BDD menos eficiente, ocorrências múltiplas de uma variável também dificultam a comparação de BDDs}
    
    \begin{columns}[c]
        \column{0.5\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (x1) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (z1) at (5.5, 4.5) {$r$};
                    \node (x2) at (1.5, 3.0) {$p$};
                    \node (x3) at (6.5, 3.0) {$p$};
                    \node (y2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (x1) to (y1);
                    \draw[thick] (x1) to (z1);
                    \draw[dashed, thick] (y1) to (x2);
                    \draw[thick, bend right=15] (y1) to (1);
                    \draw[thick] (x2) to (1);
                    \draw[dashed, thick] (x2) to (0);
                    \draw[thick] (x3) to (1);
                    \draw[dashed, thick] (x3) to (0);
                    \draw[dashed, thick] (z1) to (y2);
                    \draw[thick] (z1) to (x3);
                    \draw[dashed, thick] (y2) to (0);
                    \draw[thick] (y2) to (1);

                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (x) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (y2) at (5.5, 4.5) {$q$};
                    \node (z) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (x) to (y1);
                    \draw[thick] (x) to (y2);
                    \draw[dashed, thick] (y1) to (0);
                    \draw[thick, bend right] (y1) to (1);
                    \draw[dashed, thick] (y2) to (z);
                    \draw[thick] (y2) to (1);
                    \draw[dashed, thick] (z) to (0);
                    \draw[thick] (z) to (1);
                    
                \end{tikzpicture}

            \end{figure}

    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Conceito de ordem de um caminho}

    \begin{columns}[c]
        \column{0.2\textwidth}
        
            \begin{outline}
                \scriptsize
                \uncover<2->{
                    \1 $[p\uncover<3->{,q}\uncover<4->{,p}]$
                }
                \uncover<5->{
                    \1 $[p\uncover<6->{,q}]$
                }
                \uncover<7->{
                    \1 $[p\uncover<8->{,r}\uncover<9->{,q}]$
                }
                \uncover<10->{
                    \1 $[p\uncover<11->{,r}\uncover<12->{,p}]$
                }
            \end{outline}
                
        \column{0.4\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p1) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (r1) at (5.5, 4.5) {$r$};
                    \node (p2) at (1.5, 3.0) {$p$};
                    \node (p3) at (6.5, 3.0) {$p$};
                    \node (q2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (p1) to (q1);
                    \draw[thick] (p1) to (r1);
                    \draw[dashed, thick] (q1) to (p2);
                    \draw[thick, bend right=15] (q1) to (1);
                    \draw[thick] (p2) to (1);
                    \draw[dashed, thick] (p2) to (0);
                    \draw[thick] (p3) to (1);
                    \draw[dashed, thick] (p3) to (0);
                    \draw[dashed, thick] (r1) to (q2);
                    \draw[thick] (r1) to (p3);
                    \draw[dashed, thick] (q2) to (0);
                    \draw[thick] (q2) to (1);

                    \uncover<2-4>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<3-4>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p1) to (q1);
                    }
                    \uncover<4-4>{
                        \node[emphasis] (p2) at (1.5, 3.0) {$p$};
                        \draw[dashed, thick, emphasis] (q1) to (p2);
                        \draw[thick, emphasis] (p2) to (1);
                        \draw[dashed, thick, emphasis] (p2) to (0);
                    }
                    
                    \uncover<5-6>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<6-6>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p1) to (q1);
                        \draw[thick, bend right=15, emphasis] (q1) to (1);
                    }
                    
                    \uncover<7-9>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<8-9>{
                        \node[emphasis] (r1) at (5.5, 4.5) {$r$};
                        \draw[thick, emphasis] (p1) to (r1);
                    }
                    \uncover<9-9>{
                        \node[emphasis] (q2) at (4.3, 3.0) {$q$};
                        \draw[dashed, thick, emphasis] (r1) to (q2);
                        \draw[dashed, thick, emphasis] (q2) to (0);
                        \draw[thick, emphasis] (q2) to (1);
                    }

                    \uncover<10-12>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<11-12>{
                        \node[emphasis] (r1) at (5.5, 4.5) {$r$};
                        \draw[thick, emphasis] (p1) to (r1);
                    }
                    \uncover<12-12>{
                        \node[emphasis] (p3) at (6.5, 3.0) {$p$};
                        \draw[thick, emphasis] (r1) to (p3);
                        \draw[thick, emphasis] (p3) to (1);
                        \draw[dashed, thick, emphasis] (p3) to (0);
                    }
                \end{tikzpicture}

            \end{figure}

        \column{0.2\textwidth}
        
            \begin{outline}
                \scriptsize
                \uncover<13->{
                    \1 $[p\uncover<14->{,q}]$
                }
                \uncover<15->{
                    \1 $[p\uncover<16->{,q}\uncover<17->{,r}]$
                }
                \uncover<18->{
                    \1 $[p\uncover<19->{,q}]$
                }
            \end{outline}
            
        \column{0.2\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                    \uncover<13-14>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<14-14>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p) to (q1);
                        \draw[dashed, thick, emphasis] (q1) to (0);
                        \draw[thick, bend right, emphasis] (q1) to (1);
                    }
                    
                    \uncover<15-17>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<16-17>{
                        \node[emphasis] (q2) at (5.5, 4.5) {$q$};
                        \draw[thick, emphasis] (p) to (q2);
                    }
                    \uncover<17-17>{
                        \node[emphasis] (r) at (4.0, 3.0) {$r$};
                        \draw[dashed, thick, emphasis] (q2) to (r);
                        \draw[dashed, thick, emphasis] (r) to (0);
                        \draw[thick, emphasis] (r) to (1);
                    }
                    
                    \uncover<18-18>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<19-19>{
                        \node[emphasis] (q2) at (5.5, 4.5) {$q$};
                        \draw[thick, emphasis] (q2) to (1);
                    }
                    
                \end{tikzpicture}

            \end{figure}

    \end{columns}
    
    \only<20>{} % Só pra ter um slide a mais no final da animação, sem as cores
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{BDDs ordenados}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Quando a ordem das variáveis em qualquer caminho é sempre a mesma, o BDD passa a ser chamado Diagrama de Busca Binária Ordenado (OBDD)
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: OBDDs}

    \begin{block}{\textbf{Definição 6.6}}
        Seja $[p_1,p_2,...,p_n]$ uma lista ordenada de variáveis \underline{sem duplicação} e seja $B$ um BDD tal que todas as suas variáveis aparecem em algum lugar da lista. Dizemos que $B$ tem a ordem $[p_1,p_2,...,p_n]$ se todos os nós de variáveis de $B$ ocorrem na lista, e, para toda ocorrência de $p_i$ seguido de $p_j$ ao longo de qualquer caminho em $B$ (ou seja, $p_i \prec p_j$), temos $i < j$.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplo de BDD ordenado}

    \begin{figure}
    
        \caption{Ordem: $[p, q, r]$ (em qualquer caminho)}
    
        \begin{tikzpicture}
            [scale=1.0,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (8,6);

            \node (p) at (3.0, 5.0) {$p$};
            \node (q) at (6.0, 4.0) {$q$};
            \node (r) at (4.0, 2.5) {$r$};
            
            \node[rectangle, scale=0.7] (1) at (2.0, 1.0) {$1$};
            \node[rectangle, scale=0.7] (0) at (6.0, 1.0) {$0$};

            \draw[dashed, thick] (p) to (1);
            \draw[thick] (p) to (q);
            \draw[dashed, thick] (q) to (0);
            \draw[thick] (q) to (r);
            \draw[dashed, thick] (r) to (0);
            \draw[thick] (r) to (1);            
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------
    
%-------------------------------------------
\begin{frame}{Exemplo de BDD não ordenado}

    \begin{figure}
    
        \caption{Sem ordem única ($[p, q, r]$ à esquerda e $[p, r, q]$ à direita)}
    
        \begin{tikzpicture}
            [scale=1.0,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (8,6);

            \node (p) at (3.0, 5.5)  {$p$};
            \node (q1) at (1.5, 4.0)  {$q$};
            \node (r1) at (4.5, 4.0)  {$r$};
            
            \node (r2) at (0.6, 2.5)  {$r$};
            \node (q2) at (5.4, 2.5)  {$q$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.5) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.5) {$1$};

            \draw[dashed, thick] (p) to (q1);
            \draw[thick] (p) to (r1);
            \draw[dashed, thick] (q1) to (r2);
            \draw[thick] (q1) to (1);
            \draw[dashed, thick] (r1) to (1);
            \draw[thick] (r1) to (q2);
            \draw[dashed, thick] (r2) to (0);
            \draw[thick] (r2) to (1);
            \draw[dashed, thick] (q2) to (0);
            \draw[thick] (q2) to (1);
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{OBDDs reduzidos}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Quando são reduzidos, OBDDs passam a ser chamados de Diagramas de Busca Binária Ordenados Reduzidos (ROBDD)
            \end{minipage}
        }
    \end{center}            

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Vantagens da ordenação de BDDs}

    \begin{outline}
        \1 Reduções em um OBDDs mantêm ordem original
            \2[-] C1: compartilha nós terminais
            \2[-] C2: elimina nós não-terminais redundantes
            \2[-] C2: compartilha sub-diagramas idênticos
        
        \vspace{1em}
        
        \1 Compromisso com ordem e redução produzem representação única de funções booleanas
            \2[-] chamada de \textit{forma canônica}

            \vspace{1em}
            
        \1 Comparação de ROBDDs de ordens compatíveis é imediata
            \2[-] basta verificar se suas estruturas são idênticas
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Teorema: ROBDDs são únicos}

    \begin{block}{\textbf{Teorema 6.7}}
        A representação em ROBDD de uma função dada $\phi$ é unica. Isto é, sejam $B$ e $B^\prime$ dois ROBDDs com ordens compatíveis; se $B$ e $B^\prime$ representam a mesma função booleana, então eles têm estruturas idênticas.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Consequências da forma canônica}

    \scriptsize

    \begin{outline}
        \uncover<1->{
            \1 \textbf{Teste de equivalência semântica}. Se duas funções são representadas por OBDDs com ordens compatíveis, é possível decidir eficientemente se são equivalentes reduzindo-os e comparando sua estrutura;
        }
        
        \uncover<2->{
            \vspace{1em}
            
            \1 \textbf{Ausência de variáveis redundantes}. Se o valor de uma função booleana não depende de uma variável, então o ROBDD que a representa não contém tal variável;
        }
        
        \uncover<3->{
            \vspace{1em}
            
            \1 \textbf{Teste de validade}. Se uma função booleana é válida, seu ROBDD \underline{é igual} a $B_1$;
        }
        
        \uncover<4->{
            \vspace{1em}
            
            \1 \textbf{Teste de satisfação}. Se uma função booleana é satisfeita, então seu ROBDD \underline{não é igual} a $B_0$;
        }
        
        \uncover<5->{
            \vspace{1em}

            \1 \textbf{Teste de implicação}. Pode-se testar se uma função $\phi$ implica em outra $\psi$ calculando o ROBDD para $\phi \land \lnot{\psi}$; a implicação é verdadeira se e somente se este ROBDD é igual a $B_0$.
        }
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Impacto da escolha da ordenação}

    Considere a escolha da ordem de variáveis para a seguinte função booleana em CNF:
    $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land ... \land (p_{2n-1} \lor p_{2n})$

    \begin{outline}
        \small
        \1 Se a escolha for a ``\textit{ordem natural de ocorrência na fórmula}'' ($[p_1,p_2,p_3,...,,p_{2n-1},p_{2n}]$), o ROBDD terá $2n+2$ nós
        
        \vspace{1em}
        
        \1 Se a escolha for ``\textit{índices impares antes de índices pares}'' ($[p_1,p_3,p_5,...,p_{2n-1},p_2,p_4,p_6,...,p_{2n}]$), o ROBDD terá $2^{n+1}$ nós
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ordem ``natural'' para $n=3$}
    
    \scriptsize
    ROBDD para $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land (p_5 \land p_6)$ com a ordem de variáveis $[p_1,p_2,p_3,p_4,p_5,p_6]$
    
    \begin{figure}
    
        \begin{tikzpicture}
            [scale=0.9,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines, step=0.5] (0,0) grid (5,6);

            \node[rectangle, scale=0.7] (0) at (0.0, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (5.0, 0.0) {$1$};
            
            \node (p6) at (2.5, 1.0) {$p_6$};
            \node (p5) at (5.0, 2.0) {$p_5$};
            \node (p4) at (2.5, 3.0) {$p_4$};
            \node (p3) at (5.0, 4.0) {$p_3$};
            \node (p2) at (2.5, 5.0) {$p_2$};
            \node (p1) at (5.0, 6.0) {$p_1$};

            \draw[dashed, thick] (p1) to (p2);
            \draw[thick] (p1) to (p3);
            \draw[dashed, thick] (p2) to (0);
            \draw[thick] (p2) to (p3);
            \draw[dashed, thick] (p3) to (p4);
            \draw[thick] (p3) to (p5);
            \draw[dashed, thick] (p4) to (0);
            \draw[thick] (p4) to (p5);
            \draw[dashed, thick] (p5) to (p6);
            \draw[thick] (p5) to (1);
            \draw[dashed, thick] (p6) to (0);
            \draw[thick] (p6) to (1);
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ordem ``ímpares $\prec$ pares'' para $n=3$}

    \scriptsize
    ROBDD para $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land (p_5 \land p_6)$ com a ordem de variáveis $[p_1,p_3,p_5,p_2,p_4,p_6]$
    
    \begin{figure}
    
        \begin{tikzpicture}
            [scale=0.8,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines, step=0.5] (0,0) grid (6,7);

            \node[rectangle, scale=0.7] (0) at (0.5, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (6.0, 0.0) {$1$};
            
            \node (p1) at (3.25, 6.5) {$p_1$};
            \node (p3a) at (1.5, 5.5) {$p_3$};
            \node (p3b) at (5.0, 5.5) {$p_3$};
            \node (p5a) at (0.5, 4.5) {$p_5$};
            \node (p5b) at (2.5, 4.5) {$p_5$};
            \node (p5c) at (4.0, 4.5) {$p_5$};
            \node (p5d) at (6.0, 4.5) {$p_5$};
            \node (p2a) at (0.0, 3.3) {$p_2$};
            \node (p2b) at (1.0, 3.3) {$p_2$};
            \node (p2c) at (2.0, 3.3) {$p_2$};
            \node (p2d) at (3.0, 3.3) {$p_2$};
            \node (p4a) at (2.85, 1.7) {$p_4$};
            \node (p4b) at (5.25, 1.7) {$p_4$};
            \node (p6) at (4.0, 0.7)  {$p_6$};
            
            \draw[dashed, thick] (p1) to (p3a);
            \draw[thick] (p1) to (p3b);
            \draw[dashed, thick] (p3a) to (p5a);
            \draw[thick] (p3a) to (p5b);
            \draw[dashed, thick] (p3b) to (p5c);
            \draw[thick] (p3b) to (p5d);
            \draw[dashed, thick] (p5a) to (p2a);
            \draw[thick] (p4a) to (p6);
            \draw[dashed, thick] (p4b) to (0);
            \draw[thick] (p4b) to (1);
            \draw[thick] (p5a) to (p2b);
            \draw[dashed, thick] (p5b) to (p2c);
            \draw[thick] (p5b) to (p2d);
            \draw[dashed, thick, bend left=10] (p5c) to (p4a);
            \draw[thick] (p5c) to (p4b);
            \draw[dashed, thick, bend right=10] (p5d) to (p6);
            \draw[thick] (p5d) to (1);
            \draw[dashed, thick] (p4a) to (0);
            \draw[dashed, thick] (p6) to (0);
            \draw[thick] (p6) to (1);
            
            \draw[dashed, thick] (p2a) to (0);
            \draw[thick] (p2a) to (p4a);
            \draw[dashed, thick] (p2b) to (0);
            \draw[thick, bend right=10] (p2b) to (p4b);
            \draw[dashed, thick] (p2c) to (0);
            \draw[thick, bend left=10] (p2c) to (p6);
            \draw[dashed, thick] (p2d) to (0);
            \draw[thick] (p2d) to (1);
            
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Escolha da ordenação}

    \begin{outline}
        \1 A sensibilidade do tamanho de um ROBDD à ordem escolhida é o preço pago pelas facilidades obtidas
        
        \vspace{1em}
        
        \1 Encontrar a ordem ótima também é um problema computacional caro
            \2[-] mas há heurísticas para ordens razoavelmente boas
            \2[-] tipicamente, agrupa-se as variáveis com interações mais fortes
            
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{ROBDDs como representação}

    \begin{outline}
        \1 RODDBs permitem representações compactas de certas classes de funções booleanas
            \2[-] que seriam exponenciais em outros formatos/representações
            
        \vspace{1em}
        
        \1 Por outro lado, não se pode realizar as operações $\land$ e $\lor$ da forma ``inocente'' anteriormente estudada
            \2[-] elas podem introduzir ocorrências múltiplas de variáveis
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Principais algoritmos para ROBDDs}

    As seguintes operações estão no cerne do uso sério de ROBDDs:
    
    \begin{outline}
        \1 \textbf{Redução}. Permite reduzir OBDDs de forma eficiente
            \2[-] consiste basicamente da aplicação das simplificações C1-C3
            
        \1 \textbf{Aplicação}. Permite realizar as operações lógicas $\land$, $\lor$ e $\lnot$ (via $\phi \oplus 1$)
            \2[-] mantendo o BDD ordenado e reduzido
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Estrutura de dados}

    Os algoritmos das operações com ROBDDs utilizam como estrutura de dados uma tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$, tal que:

    \small
    \begin{outline}
        \1 $\langle v,i_l,i_r \rangle$ representa um nó qualquer no ROBDD
            \2[-] {\small com uma variável $v$}
            \2[-] {\small e identificadores de seus nós-filhos $i_{l}$ (\textit{low}, pela linha pontilhada) e $i_{h}$ (\textit{high}, pela linha sólida)}
            
        \vspace{1em}
            
        \1 $i_v$ representa um inteiro positivo que serve como identificador único do nó da variável $v$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração dessa estrutura de dados}

    \begin{columns}[c]

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=1.0,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    % Índices
                    \node[draw=none, scale=0.5, emphasis, left=0 of 0] {$\#0$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of 1] {$\#1$};
                    \node[draw=none, scale=0.5, emphasis, left=0 of q1] {$\#2$};
                    \node[draw=none, scale=0.5, emphasis, above left=0 of r] {$\#3$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of q2] {$\#4$};
                    \node[draw=none, scale=0.5, emphasis, above=0 of p] {$\#5$};
                    
                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \renewcommand{\arraystretch}{1.5}        
            \begin{table}
                \scriptsize
                \caption{Tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    $\langle 0,\textproc{null},\textproc{null} \rangle$ & $0$\\
                    $\langle 1,\textproc{null},\textproc{null} \rangle$ & $1$\\
                    $\langle q,0,1 \rangle$                             & $2$\\
                    $\langle r,0,1 \rangle$                             & $3$\\
                    $\langle q,3,1 \rangle$                             & $4$\\
                    $\langle p,2,4 \rangle$                             & $5$\\
                \end{tabular}
            \end{table}
            
    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Observações}

    Nos algoritmos apresentados a seguir, assume-se que:

    \begin{outline}
        \small
        \1 A tabela $T$ é uma variável global e $|T|$ é o número de linhas existentes nessa tabela

        \1 $T(\langle v,i_l,i_h \rangle) = \textproc{null}$ quando $(i_v, \langle v,i_l,i_h \rangle) \notin T$
        
        \1 $\textproc{lo}$ e $\textproc{hi}$ acessam os nós-filhos de um nó

        \1 $\textproc{id}$ acessa o identificador de um nó
        
        \1 $\textproc{var}$ acessa a variável de um nó
            
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de redução}

    \small
    Reduz um OBDD de maneira recorrente. Funciona assim:
    
    \begin{outline}[enumerate]
        \1 Percorre o OBDD de baixo para cima (busca em profundidade) atribuindo identificadores inteiros aos nós
        
        \1 Se o nó for terminal, atribui ou reutiliza o identificador (simplificação C1)
        
        \1 Se os identificadores dos filhos forem iguais, atribui ao nó esse mesmo identificador (simplificação C2)
        
        \1 Se existir outro nó com os mesmos filhos, atribui seu identificador ao nó (simplificação C3)
        
        \1 Caso contrário, atribui ao nó o próximo inteiro livre
        
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{getnode}}
    \begin{algorithm}[H]
        \scriptsize
        \begin{algorithmic}[1]
            \Require recebe uma variável e os identificadores dos nós canônicos de seus filhos
            \Ensure devolve o identificador do nó canônico da variável
            \Function{getnode}{$v,i_l,i_h$}
                \If{$v \notin \{0,1\}$}
                    \If{$i_l = i_h$} \Comment simplificação C2
                        \State \Return $i_l$
                    \EndIf
                \EndIf
            
                \State $i \gets T(\langle v,i_l,i_h \rangle)$
                \If{$i = \textproc{NULL}$} \Comment simplificações C1/C3
                    \State $i = |T|$
                    \State $T \gets T \cup \{(i, \langle v,i_l,i_h \rangle)\}$
                \EndIf
                \State \Return $i$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{reduce}}
    \begin{algorithm}[H]
        \scriptsize
        \begin{algorithmic}[1]
            \Require recebe o nó raiz de um diagrama a ser reduzido
            \Ensure devolve o identificador do nó canônico (isto é, do diagrama reduzido)
            \Function{reduce}{$n$}
                \If{$n \in \{0,1\}$} \Comment simplificação C1
                    \State \Return \Call{getnode}{\Call{var}{n},\textproc{null},\textproc{null}}
                \EndIf

                \State $i_n \gets T(\langle \Call{var}{n},\Call{id}{\Call{lo}{n}},\Call{id}{\Call{hi}{n}} \rangle)$
                \If{$i_n = \textproc{NULL}$}
                    \State $i_l \gets \Call{reduce}{\Call{lo}{n}}$
                    \State $i_h \gets \Call{reduce}{\Call{hi}{n}}$                

                    \State $i_n \gets \Call{getnode}{\Call{var}{n},i_l,i_h}$ \Comment simplificação C3
                \EndIf

                \State \Return $i_n$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração do algoritmo de redução}

    \begin{columns}[c]

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=1.0,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (6,6);
                    \only<-21>{\node (p) at (3.0, 4.0) {$p$};}
                    \node (q1) at (1.5, 2.0) {$q$};
                    \only<-19>{\node (q2) at (4.5, 2.0) {$q$};}
                    \node[rectangle, scale=0.7] (0a) at (0.5, 0.0) {$0$};
                    \node[rectangle, scale=0.7] (1a) at (2.5, 0.0) {$1$};
                    \only<-14>{\node[rectangle, scale=0.7] (0b) at (3.5, 0.0) {$0$};}
                    \only<-17>{\node[rectangle, scale=0.7] (1b) at (5.5, 0.0) {$1$};}
                    
                    \only<-21>{\draw[dashed, thick] (p) to (q1);}
                    \only<-19>{\draw[thick] (p) to (q2);}
                    \draw[dashed, thick] (q1) to (0a);
                    \draw[thick] (q1) to (1a);
                    \only<-14>{\draw[dashed, thick] (q2) to (0b);}
                    \only<-17>{\draw[thick] (q2) to (1b);}
                    
                    \uncover<2-21>{
                        \node[emphasis] (p) at (3.0, 4.0) {$p$};
                    }
                    \uncover<3-10>{
                        \node[emphasis] (q1) at (1.5, 2.0) {$q$};
                        \draw[dashed, thick, emphasis] (p) to (q1);
                    }
                    \uncover<4-5>{
                        \node[rectangle, scale=0.7, emphasis] (0a) at (0.5, 0.0) {$0$};
                        \draw[dashed, thick, emphasis] (q1) to (0a);
                    }
                    \uncover<5->{
                        \node[draw=none, scale=0.5, emphasis, left=0 of 0a] {$\#0$};
                    }
                    \uncover<7-8>{
                        \node[rectangle, scale=0.7, emphasis] (1a) at (2.5, 0.0) {$1$};
                        \draw[thick, emphasis] (q1) to (1a);
                    }
                    \uncover<8->{
                        \node[draw=none, scale=0.5, emphasis, left=0 of 1a] {$\#1$};
                    }
                    \uncover<10->{
                        \node[draw=none, scale=0.5, emphasis, left=0 of q1] {$\#2$};
                    }
                    \uncover<12-19>{
                        \node[emphasis] (q2) at (4.5, 2.0) {$q$};
                        \draw[thick, emphasis] (p) to (q2);
                    }
                    \uncover<13-14>{
                        \node[rectangle, scale=0.7, emphasis] (0b) at (3.5, 0.0) {$0$};
                        \draw[dashed, thick, emphasis] (q2) to (0b);
                    }
                    \uncover<14>{
                        \node[draw=none, scale=0.5, emphasis, right=0 of 0b] {$\#0$};
                    }
                    \uncover<15-19>{
                        \draw[dashed, thick] (q2) to (0a);
                    }
                    \uncover<16-17>{
                        \node[rectangle, scale=0.7, emphasis] (1b) at (5.5, 0.0) {$1$};
                        \draw[thick, emphasis] (q2) to (1b);
                    }
                    \uncover<17-17>{
                        \node[draw=none, scale=0.5, emphasis, right=0 of 1b] {$\#1$};
                    }
                    \uncover<18-19>{
                        \draw[thick] (q2) to (1a);
                    }
                    \uncover<19-19>{
                        \node[draw=none, scale=0.5, emphasis, right=0 of q2] {$\#2$};
                    }
                    \uncover<20-21>{
                        \draw[thick, bend left] (p) to (q1);
                    }
                    \uncover<21-21>{
                        \node[draw=none, scale=0.5, emphasis, left=0 of p] {redundante};
                    }
                    \only<22>{}
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \renewcommand{\arraystretch}{1.5}        
            \begin{table}
                \scriptsize
                \caption{Tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    \uncover<5->{
                        $\langle 0,\textproc{null},\textproc{null} \rangle$ & $0$
                    }\\
                    \uncover<8->{
                        $\langle 1,\textproc{null},\textproc{null} \rangle$ & $1$
                    }\\
                    \uncover<10->{
                        $\langle q,0,1 \rangle$ & $2$
                    }\\
                \end{tabular}
            \end{table}
            
    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{O compartilhamento é grande vantagem}

    \begin{columns}[c]

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (12,6);
                    
                    \node (p) at (3.0, 6.0) {$p$};
                    \node (q) at (1.5, 4.5) {$q$};
                    \node (r) at (4.5, 3.5) {$r$};
                    \node (s) at (1.5, 2.0) {$s$};
                    
                    \node[rectangle, scale=0.7] (0) at (1.5, 0.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (4.5, 0.0) {$1$};
                    
                    \draw[dashed, thick] (p) to (q);
                    \draw[thick] (p) to (r);
                    \draw[dashed, thick] (q) to (s);
                    \draw[thick] (q) to (r);
                    \draw[dashed, thick] (r) to (s);
                    \draw[thick] (r) to (1);
                    \draw[dashed, thick] (s) to (0);
                    \draw[thick] (s) to (1);
                    
                    \node (p_) at (9.0, 6.0) {$p$};
                    \node (r_) at (10.5, 3.5) {$r$};
                    \node (s_) at (7.5, 2.0) {$s$};
                    
                    \node[rectangle, scale=0.7] (0_) at (7.5, 0.0) {$0$};
                    \node[rectangle, scale=0.7] (1_) at (10.5, 0.0) {$1$};
                    
                    \draw[dashed, thick] (p_) to (s_);
                    \draw[thick] (p_) to (r_);
                    \draw[dashed, thick] (r_) to (s_);
                    \draw[thick] (r_) to (1_);
                    \draw[dashed, thick] (s_) to (0_);
                    \draw[thick] (s_) to (1_);
                    
                    \node[draw=none, scale=1.0, above=of p] (op)  {$B_\phi$};
                    \node[draw=none, scale=1.0, above=of p_] (op) {$B_\psi$};
                    
                    \node[draw=none, scale=0.5, emphasis, left=0 of 0]  {$\#0$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of 1] {$\#1$};
                    \node[draw=none, scale=0.5, emphasis, left=0 of s]  {$\#2$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of r] {$\#3$};
                    \node[draw=none, scale=0.5, emphasis, left=0 of q]  {$\#4$};
                    \node[draw=none, scale=0.5, emphasis, above=0 of p] {$\#5$};
                    
                    \node[draw=none, scale=0.5, emphasis, left=0 of 0_]  {$\#0$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of 1_] {$\#1$};
                    \node[draw=none, scale=0.5, emphasis, left=0 of s_]  {$\#2$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of r_] {$\#3$};
                    \node[draw=none, scale=0.5, emphasis, above=0 of p_] {$\#6$};
                    
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \renewcommand{\arraystretch}{1.5}        
            \begin{table}
                \scriptsize
                \caption{Tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    $\langle 0,\textproc{null},\textproc{null} \rangle$ & $0$\\
                    $\langle 1,\textproc{null},\textproc{null} \rangle$ & $1$\\
                    $\langle s,0,1 \rangle$ & $2$\\
                    $\langle r,2,1 \rangle$ & $3$\\
                    $\langle q,2,3 \rangle$ & $4$\\
                    $\langle p,4,3 \rangle$ & $5$\\
                    $\langle p,2,3 \rangle$ & $6$\\
                \end{tabular}
            \end{table}
            
    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de aplicação}

    \small
    Obtém o resultado de $B_\phi~op~B_\psi$, sendo $op$ uma operação booleana ($\land$, $\lor$, $\oplus$ ou $\lnot$ via $B_\phi \oplus 1$). Funciona assim:

    \begin{outline}[enumerate]
        \1 inicia com a variável $v$ de maior ordem (mais à esquerda na lista de ordenação)
        \1 divide o problema em dois subproblemas, dependendo de $v$ ser $0$ ou $1$, e resolve de maneira recorrente
        \1 nas folhas, aplica a operação booleana $op$ diretamente
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Dependência conceitual}

    \centering
    O algoritmo para a aplicação de operações booleanas entre OBDDs utiliza o conceito da \underline{Expansão de Shannon}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: restrições}

    \begin{block}{\textbf{Definição 6.9}}
        Sejam $\phi$ uma expressão booleana e $p$ uma variável. Denotamos por $\phi[0/p]$ a expressão booleana obtida substituindo-se todas as ocorrências de $p$ em $\phi$ por $0$. A expressão $\phi[1/p]$ é definida de maneira semelhante. As expressões $\phi[0/p]$ e $\phi[1/p]$ são chamadas de \underline{restrições} em $\phi$ com relação à variável $p$.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplos de restrições}

    Para $\phi \equiv p \land (q \lor \lnot{p})$ tem-se:

    \begin{outline}
        \1 $\phi[0/p]$ é igual a $0 \land (q \lor \lnot{0})$
            \2[-] que é semanticamente equivalente a $0$
            
        \vspace{1em}
        
        \1 $\phi[1/p]$ é igual a $1 \land (q \lor \lnot{1})$
            \2[-] que é semanticamente equivalente a $q$
            
        \vspace{1em}
        
        \1 $\phi[0/q]$ é igual a $p \land (0 \lor \lnot{p})$
            \2[-] que é semanticamente equivalente a $\bot$
            
        \vspace{1em}
        
        \1 $\phi[1/q]$ é igual a $p \land (1 \lor \lnot{p})$
            \2[-] que é semanticamente equivalente a $p$
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Uso das restrições}

    \begin{outline}
        \1 As restrições permitem executar recorrências em expressões booleanas decompondo-as em expressões mais simples
        
        \vspace{1em}
        
        \1 Se $p$ é uma variável em $\phi$, então $\phi$ é equivalente a $\lnot{p} \land \phi[0/p] \lor p \land \phi[1/p]$
            \2[-] facilmente verificável
            \2[-] fazendo $p = 0$ resulta em $\phi[0/p]$
            \2[-] fazendo $p = 1$ resulta em $\phi[1/p]$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Lema: Expansão de Shannon}

    \begin{block}{\textbf{Lema 6.10}}
        Para todas as expressões booleanas $\phi$ e todas as variáveis $p$ (mesmo as que não ocorrem em $\phi$), tem-se a chamada \underline{Expansão de Shannon}:\\[1em]
        $\phi \equiv \lnot{p} \land \phi[0/p] \lor p \land \phi[1/p]$
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Uso no algoritmo de aplicação}

    \small
    A Expansão de Shannon permite expressar qualquer operador da gramática da Lógica Proposicional:

    \scriptsize
    $$\phi~op~\psi \equiv \lnot{p_i} \land (\phi[0/p_i]~op~\psi[0/p_i]) \lor p_i \land (\phi[1/p_i]~op~\psi[1/p_i])$$
    
    \begin{center}
        \ovalbox{
            \begin{minipage}[h]{0.9\columnwidth}
                \noindent\scriptsize
                E, no algoritmo de aplicação, é usada para eliminar as variáveis com a aplicação das restrições
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Programação dinâmica}

    \begin{outline}
        \1 O algoritmo de aplicação também utiliza programação dinâmica para melhorar a eficiência
            \2[-] recursão com tabela para armazenar valores já calculados
    \end{outline}
    
    \begin{center}
        \ovalbox{
            \begin{minipage}[h]{0.7\columnwidth}
                \noindent\scriptsize\centering
                No pseudocódigo do algoritmo, a seguir, essa tabela é referenciada como $C$ (de \textit{cache})
            \end{minipage}
        }
    \end{center}    
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{apply}}
    \begin{algorithm}[H]
        \tiny
        \begin{algorithmic}[1]
            \Require recebe um operador lógico e os nós raízes de dois diagramas com ordens compatíveis
            \Ensure devolve o identificador do nó canônico do resultado da operação
            \Function{apply}{$op,n_\phi,n_\psi$}
                \State $v_\phi \gets \Call{var}{n_\phi}$
                \State $v_\psi \gets \Call{var}{n_\psi}$
                
                \If{$(v_\phi \in \{0,1\}) \land (v_\psi \in \{0,1\})$} \Comment se ambos são nós terminais
                    \State $r \gets n_\phi~op~n_\psi$ \Comment aplica a operação diretamente
                    \State \Return $\Call{getnode}{r,\textproc{null},\textproc{null}}$
                \EndIf
                
                \State $r \gets C(op,n_\phi,n_\psi)$ \Comment verificação da programação dinâmica
                
                \If{r = \textproc{null}}
                    \If{$v_\phi = v_\psi$} \Comment se têm a mesma variável
                        \State $i_l \gets \Call{apply}{op,\Call{lo}{n_\phi},\Call{lo}{n_\psi}}$
                        \State $i_h \gets \Call{apply}{op,\Call{hi}{n_\phi},\Call{hi}{n_\psi}}$
                        \State $r \gets \Call{getnode}{v_\phi,i_l,i_h}$
                    \Else
                        \If{$v_\phi \prec v_\psi$} \Comment se $v_\phi$ ocorre antes de $v_\psi$
                            \State $i_l \gets \Call{apply}{op,\Call{lo}{n_\phi},n_\psi}$
                            \State $i_h \gets \Call{apply}{op,\Call{hi}{n_\phi},n_\psi}$
                            \State $ r \gets \Call{getnode}{v_\phi,i_l,i_h}$
                        \Else \Comment se $v_\phi$ ocorre após $v_\psi$
                            \State $i_l \gets \Call{apply}{op,n_\phi,\Call{lo}{n_\psi}}$
                            \State $i_h \gets \Call{apply}{op,n_\phi,\Call{hi}{n_\psi}}$
                            \State $r \gets \Call{getnode}{v_\psi,i_l,i_h}$
                        \EndIf
                    \EndIf
                    \State $C \gets C \cup \{(\langle op,n_\phi,n_\psi \rangle, r)\}$ \Comment atualização da tabela da progamação dinâmica
                \EndIf
                \State \Return $r$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração do algoritmo de aplicação}

    \centering
    Ordem: $[p,q,r,s]$

    \vspace{-1em}
    
    \begin{figure}
        \begin{tikzpicture}
            [scale=0.7,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (20,6);
            
            \node (p) at (3.0, 6.0) {$p$};
            \node (q) at (1.5, 4.5) {$q$};
            \node (r) at (4.5, 3.5) {$r$};
            \node (s) at (1.5, 2.0) {$s$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.0) {$1$};
            
            \draw[dashed, thick] (p) to (q);
            \draw[thick] (p) to (r);
            \draw[dashed, thick] (q) to (s);
            \draw[thick] (q) to (r);
            \draw[dashed, thick] (r) to (s);
            \draw[thick] (r) to (1);
            \draw[dashed, thick] (s) to (0);
            \draw[thick] (s) to (1);
            
            \node[draw=none, scale=1.5] (op) at (6.0, 3.0) {$\lor$};

            \node (p_) at (9.0, 6.0) {$p$};
            \node (r_) at (10.5, 3.5) {$r$};
            \node (s_) at (7.5, 2.0) {$s$};
            
            \node[rectangle, scale=0.7] (0_) at (7.5, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1_) at (10.5, 0.0) {$1$};
            
            \draw[dashed, thick] (p_) to (s_);
            \draw[thick] (p_) to (r_);
            \draw[dashed, thick] (r_) to (s_);
            \draw[thick] (r_) to (1_);
            \draw[dashed, thick] (s_) to (0_);
            \draw[thick] (s_) to (1_);
            
            \node[draw=none, scale=1.5] (op) at (12.0, 3.0) {$=$};

            \uncover<32->{\node (p__) at (15.0, 6.0) {$p$};}
            \uncover<24->{\node (q__) at (13.5, 4.5) {$q$};}
            \uncover<22->{\node (r__) at (16.5, 3.5) {$r$};}
            \uncover<11->{\node (s__) at (13.5, 2.0) {$s$};}
            
            \uncover<6->{\node[rectangle, scale=0.7] (0__) at (13.5, 0.0) {$0$};}
            \uncover<9->{\node[rectangle, scale=0.7] (1__) at (16.5, 0.0) {$1$};}
            
            \uncover<32->{\draw[dashed, thick] (p__) to (q__);}
            \uncover<32->{\draw[thick] (p__) to (r__);}
            \uncover<24->{\draw[dashed, thick] (q__) to (s__);}
            \uncover<24->{\draw[thick] (q__) to (r__);}
            \uncover<22->{\draw[dashed, thick] (r__) to (s__);}
            \uncover<22->{\draw[thick] (r__) to (1__);}
            \uncover<11->{\draw[dashed, thick] (s__) to (0__);}
            \uncover<11->{\draw[thick] (s__) to (1__);}
            
            \uncover<2-31>{
                \node[emphasis] (p) at (3.0, 6.0) {$p$};
                \node[emphasis] (p_) at (9.0, 6.0) {$p$};
            }
            \uncover<3-24>{
                \node[emphasis] (q) at (1.5, 4.5) {$q$};
                \draw[dashed, thick, emphasis] (p) to (q);
                \node[emphasis] (s_) at (7.5, 2.0) {$s$};
                \draw[dashed, thick, emphasis] (p_) to (s_);
            }
            \uncover<4-11>{
                \node[emphasis] (s) at (1.5, 2.0) {$s$};
                \draw[dashed, thick, emphasis] (q) to (s);
            }
            \uncover<5-6>{
                \node[rectangle, scale=0.7, emphasis] (0) at (1.5, 0.0) {$0$};
                \draw[dashed, thick, emphasis] (s) to (0);
                \node[rectangle, scale=0.7, emphasis] (0_) at (7.5, 0.0) {$0$};
                \draw[dashed, thick, emphasis] (s_) to (0_);
            }
            \uncover<8-9>{
                \node[rectangle, scale=0.7, emphasis] (1) at (4.5, 0.0) {$1$};
                \draw[thick, emphasis] (s) to (1);
                \node[rectangle, scale=0.7, emphasis] (1_) at (10.5, 0.0) {$1$};
                \draw[thick, emphasis] (s_) to (1_);
            }
            \uncover<13-22>{
                \node[emphasis] (r) at (4.5, 3.5) {$r$};
                \draw[thick, emphasis] (q) to (r);
            }
            \uncover<14-14>{
                \node[emphasis] (s) at (1.5, 2.0) {$s$};
                \draw[dashed, thick, emphasis] (r) to (s);
            }
            \uncover<16-20>{
                \node[rectangle, scale=0.7, emphasis] (1) at (4.5, 0.0) {$1$};
                \draw[thick, emphasis] (r) to (1);
            }
            \uncover<17-17>{
                \node[rectangle, scale=0.7, emphasis] (0_) at (7.5, 0.0) {$0$};
                \draw[dashed, thick, emphasis] (s_) to (0_);
            }
            \uncover<19-19>{
                \node[rectangle, scale=0.7, emphasis] (1_) at (10.5, 0.0) {$1$};
                \draw[thick, emphasis] (s_) to (1_);
            }
            \uncover<26-30>{
                \node[emphasis] (r) at (4.5, 3.5) {$r$};
                \draw[thick, emphasis] (p) to (r);
                \node[emphasis] (r_) at (10.5, 3.5) {$r$};
                \draw[thick, emphasis] (p_) to (r_);
            }
            \uncover<27-27>{
                \node[emphasis] (s) at (1.5, 2.0) {$s$};
                \draw[dashed, thick, emphasis] (r) to (s);
                \node[emphasis] (s_) at (7.5, 2.0) {$s$};
                \draw[dashed, thick, emphasis] (r_) to (s_);
            }
            \uncover<29-29>{
                \node[rectangle, scale=0.7, emphasis] (1) at (4.5, 0.0) {$1$};
                \draw[thick, emphasis] (r) to (1);
                \node[rectangle, scale=0.7, emphasis] (1_) at (10.5, 0.0) {$1$};
                \draw[thick, emphasis] (r_) to (1_);
            }
            
        \end{tikzpicture}

    \end{figure}

    {\scriptsize
        \only<1>{\hfill}
        \only<2>{mesma variável: recorrência em ambos diagramas}
        \only<3>{$q \prec s$: recorrência no diagrama da esquerda}
        \only<4>{mesma variável: recorrência em ambos diagramas}
        \only<5>{nós terminais: aplica operação ($0 \lor 0 = 0$)}
        \only<6-7>{\hfill}
        \only<8>{nós terminais: aplica operação ($1 \lor 1 = 1$)}
        \only<9>{\hfill}
        \only<10>{Conclusão parcial: cria/compartilha subdiagrama}
        \only<11-12>{\hfill}
        \only<13>{$r \prec s$: recorrência no diagrama da esquerda}
        \only<14>{programação dinâmica: operação entre subdiagramas já calculada}
        \only<15>{\hfill}
        \only<16>{$1 \succ s$: recorrência no diagrama da direita}
        \only<17>{nós terminais: aplica operação ($1 \lor 0 = 1$)}
        \only<18>{\hfill}
        \only<19>{nós terminais: aplica operação ($1 \lor 1 = 1$)}
        \only<20>{simplificação: nó $s$ que sempre chega a $1$ ignorado}
        \only<21>{Conclusão parcial: cria/compartilha subdiagrama}
        \only<22>{\hfill}
        \only<23>{Conclusão parcial: cria/compartilha subdiagrama}
        \only<24-25>{\hfill}
        \only<26>{mesma variável: recorrência em ambos diagramas}
        \only<27>{programação dinâmica: operação entre subdiagramas já calculada}
        \only<28>{\hfill}
        \only<29>{programação dinâmica: operação entre subdiagramas já calculada}
        \only<30>{\hfill}
        \only<31>{Conclusão parcial: cria/compartilha subdiagrama}
    }
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Outros algoritmos para ROBDDs}

    Há também esses outros dois algoritmos importantes:
    
    \begin{outline}
        \1 \textbf{Restrição}. Permite eliminar variáveis em diagramas
            
        \1 \textbf{Existência}. Permite utilizar quantificadores em expressões
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{O algoritmo de restrição}

    \small
    O algoritmo de restrição (\textproc{restrict}) calcula o RODDB que representem $\phi[0/p]$ ou $\phi[1/p]$. É bem simples, e funciona assim:

    \begin{outline}
        \1 Para cada nó $n$ marcado com a variável $p$, as arestas que entram são redirecionadas
            \2[-] para $\Call{lo}{n}$ se o valor de restrição é $0$
            \2[-] para $\Call{hi}{n}$ se o valor de restrição é $1$
            
        \vspace{1em}
            
        \1 Então, o algoritmo de redução é chamado para reduzir o OBDD resultante
        
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{O algoritmo de existência}

    \small
    O algoritmo de existência (\textproc{exists}) representa expressões em termos de subconjuntos de restrições. Funciona assim:

    \begin{outline}
        \1 Seja uma expressão $p \lor (\lnot{q} \land r)$. Ela só é verdadeira se $p = 1$ ou se $y = 0$ e $r = 1$
            \2[-] ou seja, tratam-se de restrições sobre $p$, $q$ e $r$
            
        \vspace{1em}
            
        \1 Pode-se expressar o relaxamento em um subconjunto de variáveis
            \2[-] escrevendo $\exists{p.\phi}$ para a função booleana $\phi$ com restrição sobre $p$ relaxada
            \2[-] formalmente $\exists{p.\phi} \defeq \phi[0/p] \lor \phi[1/p]$
        
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{O que significa}

    \centering
    Essencialmente, $\exists{p.\phi}$ significa que $\phi$ é verdadeira se puder ser feita verdadeira para $p = 0$ ou para $p = 1$

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Analogamente}

    \centering
    Analogamente, $\forall{p.\phi}$ significa que $\phi$ é verdadeira se puder ser feita verdadeira tanto para $p = 0$ como para $p = 1$
    
    \begin{center}
        \ovalbox{
            \begin{minipage}[h]{0.9\columnwidth}
                \noindent\scriptsize\justifying
                E por isso o quantificador booleano $\forall$ é o dual de $\exists$:\\
                $$\forall{p.\phi} \defeq \phi[0/p] \land \phi[1/p]$$
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{O algoritmo \textproc{exists}}

    Assim, o algoritmo \textproc{exists} pode ser implementado em termos dos algoritmos \textproc{apply} e \textproc{restrict} da seguinte forma:
    \\
    \scriptsize
    $$\Call{apply}{\lor,\Call{restrict}{0,p,B_\phi},\Call{restrict}{1,p,B_\phi}}$$

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Construção de ROBDDs}

    \renewcommand{\arraystretch}{1.2}
    \begin{table}
        \scriptsize
        \caption{Formas de construção de ROBDDs com os algoritmos}
        \begin{tabular}{c|c}
            Fórmula booleana $\phi$ & ROBDD $B_\phi representante$\\
            \hline
            $0$ & $B_0$\\
            $1$ & $B_1$\\
            $p$ & $B_p$\\
            $\lnot{\phi}$ & trocar $0$ por $1$ e vice-versa em $B_\phi$\\
            $\phi \lor \psi$ & $\textproc{apply}(\lor,B_\phi,B_\psi)$\\
            $\phi \land \psi$ & $\textproc{apply}(\land,B_\phi,B_\psi)$\\
            $\phi \oplus \psi$ & $\textproc{apply}(\oplus,B_\phi,B_\psi)$\\
            $\phi[1/p]$ & $\textproc{restrict}(1,p,B_\phi)$\\
            $\phi[0/p]$ & $\textproc{restrict}(0,p,B_\phi)$\\
            $\exists{p.\phi}$ & $\textproc{apply}(\lor,B_{\phi[0/p]},B_{\phi[1/p]})$\\
            $\forall{p.\phi}$ & $\textproc{apply}(\land,B_{\phi[0/p]},B_{\phi[1/p]})$\\
        \end{tabular}
    \end{table}    

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Desempenho dos algoritmos}

    \renewcommand{\arraystretch}{1.2}
    \begin{table}
        \scriptsize
        \caption{Formas de construção de ROBDDs com os algoritmos}
        \begin{tabular}{c|c}
            Algoritmo & Complexidade no Tempo\\
            \hline
            \textproc{reduce} & $O(|B| \times \log |B|)$\\
            \textproc{apply} & $O(|B_\phi| \times |B_\psi|)$\\
            \textproc{restrict} & $O(|B| \times \log |B|)$\\
            \textproc{exists} & NP completo\\
        \end{tabular}
    \end{table}    

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Biblioteca de ROBDDs para o EP}

    \begin{outline}
        \1 BDDs from Python EDA: \url{http://pyeda.readthedocs.org/en/latest/bdd.html}
            \2[-] Python EDA é uma biblioteca Python para projetos de automação
            \2[-] usando álgebra booleana
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}[fragile]{Uso é simples}

\small
\begin{verbatim}
>>> from pyeda.inter import *
        
>>> f = expr("a & b | a & c | b & c")
>>> f
Or(And(a, b), And(a, c), And(b, c))
>>> f = expr2bdd(f)
>>> f
<pyeda.boolalg.bdd.BinaryDecisionDiagram at 0x7f556874ed68>
\end{verbatim}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}[fragile]{Verificações}

\small
\begin{verbatim}
>>> f = ~a & ~b | ~a & b | a & ~b | a & b
>>> f
1
>>> f.is_one()
True
>>> g = (~a | ~b) & (~a | b) & (a | ~b) & (a | b)
>>> g
0
>>> g.is_zero()
True
\end{verbatim}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}[fragile]{Operações}

\small
\begin{verbatim}
>>> f = expr("a & b | a & c | b & c")

>>> f.restrict({a: 0})
<pyeda.boolalg.bdd.BinaryDecisionDiagram at 0x7f556874eb38>
>>> f.restrict({a: 1, b: 0})
c
>>> f.restrict({a: 1, b: 1})
1
\end{verbatim}

\end{frame}
%-------------------------------------------

\end{document}