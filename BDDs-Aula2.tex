\providecommand\classopts{}
\expandafter\documentclass\expandafter[table, usenames, svgnames, dvipsnames,14pt, \classopts]{beamer}
\usetheme[everytitleformat=regular,frametitleformat=regular,progressbar=frametitle,numbering=fraction]{m} % load the metropolis theme
\usefonttheme[onlymath]{serif}

\usepackage[portuguese]{babel} % For writing in Portuguese
\usepackage[utf8]{inputenc} % For using unicode characters (easier with accents)
\usepackage{outlines} % For labeled itemize/enumerate blocks
\usepackage{fancybox} % For drawing fancy boxes
\usepackage{ragged2e} % For justifying text
\usepackage{multirow} % For spanning multiple rows in a table
\usepackage{caption}  % For custom captions in tables and figures
\captionsetup{labelformat=empty}

\usepackage{tikz-qtree} % For the graphs
\usetikzlibrary{shapes.arrows,trees,positioning}

\usepackage{stmaryrd} % For some logic symbols
\usepackage{amsmath} % For math symbols
\boldmath

\usepackage{algorithm} % For algorithms...
\usepackage{algpseudocode} % ...in pseudocode
\usepackage{fixltx2e}
\MakeRobust{\Call} % For allowing nested uses of \Call

\usepackage{tabularx} % For creating tables with data centered in cells
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\title{Diagramas de Decisão Binária (BDDs)}
\subtitle{Aula 2}
\date{7 de outubro de 2015}
\author{Luiz Carlos Vieira}
\institute{MAC0239 - Introdução à Lógica e Verificação de Programas}

% definition symbol
\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

% Image's path
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\graphicspath{{./images/}}

\setbeamerfont{footnote}{size=\tiny}

\definecolor{good}{rgb}{0.14,0.67,0.70} %blueish
\definecolor{bad}{rgb}{0.92,0.30,0.36} % redish
\definecolor{ok}{rgb}{0.97,0.61,0.12} % orangeish
\definecolor{emphasis}{rgb}{0.92,0.00,0.70} % pinkish

% Tradução dos comandos de algoritmos
\algrenewcommand\algorithmicfunction{\textbf{função}}
\algrenewcommand\algorithmicprocedure{\textbf{procedimento}}
\algrenewcommand\algorithmicend{\textbf{fim}}
\algrenewcommand\algorithmicif{\textbf{se}}
\algrenewcommand\algorithmicthen{\textbf{então}}
\algrenewcommand\algorithmicreturn{\textbf{devolva}}
\algrenewcommand\algorithmicrequire{\textbf{precondição:}}
\algrenewcommand\algorithmicensure{\textbf{pós-condição:}}

\algrenewcommand\alglinenumber[1]{\tiny #1:}

\begin{document}
\maketitle

%-------------------------------------------
\begin{frame}{Conteúdo}

    \begin{outline}
        \1 BDDs ordenados e reduzidos (ROBDDs)

        \vspace{1em}
            
        \1 Algoritmos para ROBDDs
            \2[-] algoritmo \texttt{reduzir}
            \2[-] algoritmo \texttt{aplicar}
            \2[-] algoritmo \texttt{restringir}
            \2[-] algoritmo \texttt{existe}
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Relembrando: múltiplas ocorrências}

    \begin{columns}[c]
        \column{0.4\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (x1) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (z1) at (5.5, 4.5) {$r$};
                    \node (x2) at (1.5, 3.0) {$p$};
                    \node (x3) at (6.5, 3.0) {$p$};
                    \node (y2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (x1) to (y1);
                    \draw[thick] (x1) to (z1);
                    \draw[dashed, thick] (y1) to (x2);
                    \draw[thick, bend right=15] (y1) to (1);
                    \draw[thick, emphasis] (x2) to (1);
                    \draw[dashed, thick] (x2) to (0);
                    \draw[thick] (x3) to (1);
                    \draw[dashed, thick] (x3) to (0);
                    \draw[dashed, thick] (z1) to (y2);
                    \draw[thick] (z1) to (x3);
                    \draw[dashed, thick] (y2) to (0);
                    \draw[thick] (y2) to (1);                    

                \end{tikzpicture}

            \end{figure}

        \column{0.6\textwidth}
            
            \begin{outline}
                \small
                \1 A definição de BDDs não impede uma variável de ocorrer mais de uma vez em um caminho
                
                \vspace{1em}
                
                \1 Mas tal representação pode incorrer em desperdícios
                    \2[-] {\scriptsize linha sólida do $p$ à esquerda (colorida) jamais será percorrida}
            \end{outline}
            
            \begin{center}
                \ovalbox{
                    \begin{minipage}[h]{0.9\columnwidth}
                        \noindent\scriptsize\justifying
                        Esse é um resultado comum após as operações discutidas na aula anterior
                    \end{minipage}
                }
            \end{center}

    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Relembrando: comparação de BDDs}

    {\small Além de tornar um BDD menos eficiente, ocorrências múltiplas de uma variável também dificultam a comparação de BDDs}
    
    \begin{columns}[c]
        \column{0.5\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (x1) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (z1) at (5.5, 4.5) {$r$};
                    \node (x2) at (1.5, 3.0) {$p$};
                    \node (x3) at (6.5, 3.0) {$p$};
                    \node (y2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (x1) to (y1);
                    \draw[thick] (x1) to (z1);
                    \draw[dashed, thick] (y1) to (x2);
                    \draw[thick, bend right=15] (y1) to (1);
                    \draw[thick] (x2) to (1);
                    \draw[dashed, thick] (x2) to (0);
                    \draw[thick] (x3) to (1);
                    \draw[dashed, thick] (x3) to (0);
                    \draw[dashed, thick] (z1) to (y2);
                    \draw[thick] (z1) to (x3);
                    \draw[dashed, thick] (y2) to (0);
                    \draw[thick] (y2) to (1);

                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (x) at (4.0, 6.0) {$p$};
                    \node (y1) at (2.5, 4.5) {$q$};
                    \node (y2) at (5.5, 4.5) {$q$};
                    \node (z) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (x) to (y1);
                    \draw[thick] (x) to (y2);
                    \draw[dashed, thick] (y1) to (0);
                    \draw[thick, bend right] (y1) to (1);
                    \draw[dashed, thick] (y2) to (z);
                    \draw[thick] (y2) to (1);
                    \draw[dashed, thick] (z) to (0);
                    \draw[thick] (z) to (1);
                    
                \end{tikzpicture}

            \end{figure}

    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Conceito de ordem de um caminho}

    \begin{columns}[c]
        \column{0.2\textwidth}
        
            \begin{outline}
                \scriptsize
                \uncover<2->{
                    \1 $[p\uncover<3->{,q}\uncover<4->{,p}]$
                }
                \uncover<5->{
                    \1 $[p\uncover<6->{,q}]$
                }
                \uncover<7->{
                    \1 $[p\uncover<8->{,r}\uncover<9->{,q}]$
                }
                \uncover<10->{
                    \1 $[p\uncover<11->{,r}\uncover<12->{,p}]$
                }
            \end{outline}
                
        \column{0.4\textwidth}

            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p1) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (r1) at (5.5, 4.5) {$r$};
                    \node (p2) at (1.5, 3.0) {$p$};
                    \node (p3) at (6.5, 3.0) {$p$};
                    \node (q2) at (4.3, 3.0) {$q$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.0, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (6.0, 1.0) {$1$};

                    \draw[dashed, thick] (p1) to (q1);
                    \draw[thick] (p1) to (r1);
                    \draw[dashed, thick] (q1) to (p2);
                    \draw[thick, bend right=15] (q1) to (1);
                    \draw[thick] (p2) to (1);
                    \draw[dashed, thick] (p2) to (0);
                    \draw[thick] (p3) to (1);
                    \draw[dashed, thick] (p3) to (0);
                    \draw[dashed, thick] (r1) to (q2);
                    \draw[thick] (r1) to (p3);
                    \draw[dashed, thick] (q2) to (0);
                    \draw[thick] (q2) to (1);

                    \uncover<2-4>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<3-4>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p1) to (q1);
                    }
                    \uncover<4-4>{
                        \node[emphasis] (p2) at (1.5, 3.0) {$p$};
                        \draw[dashed, thick, emphasis] (q1) to (p2);
                        \draw[thick, emphasis] (p2) to (1);
                        \draw[dashed, thick, emphasis] (p2) to (0);
                    }
                    
                    \uncover<5-6>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<6-6>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p1) to (q1);
                        \draw[thick, bend right=15, emphasis] (q1) to (1);
                    }
                    
                    \uncover<7-9>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<8-9>{
                        \node[emphasis] (r1) at (5.5, 4.5) {$r$};
                        \draw[thick, emphasis] (p1) to (r1);
                    }
                    \uncover<9-9>{
                        \node[emphasis] (q2) at (4.3, 3.0) {$q$};
                        \draw[dashed, thick, emphasis] (r1) to (q2);
                        \draw[dashed, thick, emphasis] (q2) to (0);
                        \draw[thick, emphasis] (q2) to (1);
                    }

                    \uncover<10-12>{
                        \node[emphasis] (p1) at (4.0, 6.0) {$p$};
                    }
                    \uncover<11-12>{
                        \node[emphasis] (r1) at (5.5, 4.5) {$r$};
                        \draw[thick, emphasis] (p1) to (r1);
                    }
                    \uncover<12-12>{
                        \node[emphasis] (p3) at (6.5, 3.0) {$p$};
                        \draw[thick, emphasis] (r1) to (p3);
                        \draw[thick, emphasis] (p3) to (1);
                        \draw[dashed, thick, emphasis] (p3) to (0);
                    }
                \end{tikzpicture}

            \end{figure}

        \column{0.2\textwidth}
        
            \begin{outline}
                \scriptsize
                \uncover<13->{
                    \1 $[p\uncover<14->{,q}]$
                }
                \uncover<15->{
                    \1 $[p\uncover<16->{,q}\uncover<17->{,r}]$
                }
                \uncover<18->{
                    \1 $[p\uncover<19->{,q}]$
                }
            \end{outline}
            
        \column{0.2\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.6,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                    \uncover<13-14>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<14-14>{
                        \node[emphasis] (q1) at (2.5, 4.5) {$q$};
                        \draw[dashed, thick, emphasis] (p) to (q1);
                        \draw[dashed, thick, emphasis] (q1) to (0);
                        \draw[thick, bend right, emphasis] (q1) to (1);
                    }
                    
                    \uncover<15-17>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<16-17>{
                        \node[emphasis] (q2) at (5.5, 4.5) {$q$};
                        \draw[thick, emphasis] (p) to (q2);
                    }
                    \uncover<17-17>{
                        \node[emphasis] (r) at (4.0, 3.0) {$r$};
                        \draw[dashed, thick, emphasis] (q2) to (r);
                        \draw[dashed, thick, emphasis] (r) to (0);
                        \draw[thick, emphasis] (r) to (1);
                    }
                    
                    \uncover<18-18>{
                        \node[emphasis] (p) at (4.0, 6.0) {$p$};
                    }
                    \uncover<19-19>{
                        \node[emphasis] (q2) at (5.5, 4.5) {$q$};
                        \draw[thick, emphasis] (q2) to (1);
                    }
                    
                \end{tikzpicture}

            \end{figure}

    \end{columns}
    
    \only<20>{} % Só pra ter um slide a mais no final da animação, sem as cores
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{BDDs ordenados}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Quando a ordem das variáveis em qualquer caminho é sempre a mesma, o BDD passa a ser chamado Diagrama de Busca Binária Ordenado (OBDD)
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: OBDDs}

    \begin{block}{\textbf{Definição 6.6}}
        Seja $[p_1,p_2,...,p_n]$ uma lista ordenada de variáveis \underline{sem duplicação} e seja $B$ um BDD tal que todas as suas variáveis aparecem em algum lugar da lista. Dizemos que $B$ tem a ordem $[p_1,p_2,...,p_n]$ se todos os nós de variáveis de $B$ ocorrem na lista, e, para toda ocorrência de $p_i$ seguido de $p_j$ ao longo de qualquer caminho em $B$ (ou seja, $p_i \prec p_j$), temos $i < j$.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplo de BDD ordenado}

    \begin{figure}
    
        \caption{Ordem: $[p, q, r]$ (em qualquer caminho)}
    
        \begin{tikzpicture}
            [scale=1.0,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (8,6);

            \node (p) at (3.0, 5.0) {$p$};
            \node (q) at (6.0, 4.0) {$q$};
            \node (r) at (4.0, 2.5) {$r$};
            
            \node[rectangle, scale=0.7] (1) at (2.0, 1.0) {$1$};
            \node[rectangle, scale=0.7] (0) at (6.0, 1.0) {$0$};

            \draw[dashed, thick] (p) to (1);
            \draw[thick] (p) to (q);
            \draw[dashed, thick] (q) to (0);
            \draw[thick] (q) to (r);
            \draw[dashed, thick] (r) to (0);
            \draw[thick] (r) to (1);            
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------
    
%-------------------------------------------
\begin{frame}{Exemplo de BDD não ordenado}

    \begin{figure}
    
        \caption{Sem ordem única ($[p, q, r]$ à esquerda e $[p, r, q]$ à direita)}
    
        \begin{tikzpicture}
            [scale=1.0,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (8,6);

            \node (p) at (3.0, 5.5)  {$p$};
            \node (q1) at (1.5, 4.0)  {$q$};
            \node (r1) at (4.5, 4.0)  {$r$};
            
            \node (r2) at (0.6, 2.5)  {$r$};
            \node (q2) at (5.4, 2.5)  {$q$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.5) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.5) {$1$};

            \draw[dashed, thick] (p) to (q1);
            \draw[thick] (p) to (r1);
            \draw[dashed, thick] (q1) to (r2);
            \draw[thick] (q1) to (1);
            \draw[dashed, thick] (r1) to (1);
            \draw[thick] (r1) to (q2);
            \draw[dashed, thick] (r2) to (0);
            \draw[thick] (r2) to (1);
            \draw[dashed, thick] (q2) to (0);
            \draw[thick] (q2) to (1);
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{OBDDs reduzidos}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Quando são reduzidos, OBDDs passam a ser chamados de Diagramas de Busca Binária Ordenados Reduzidos (ROBDD)
            \end{minipage}
        }
    \end{center}            

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Vantagens da ordenação de BDDs}

    \begin{outline}
        \1 Reduções em um OBDDs mantêm ordem original
            \2[-] C1: compartilha nós terminais
            \2[-] C2: elimina nós não-terminais redundantes
            \2[-] C2: compartilha sub-diagramas idênticos
        
        \vspace{1em}
        
        \1 Compromisso com ordem e redução produzem representação única de funções booleanas
            \2[-] chamada de \textit{forma canônica}

            \vspace{1em}
            
        \1 Comparação de ROBDDs de ordens compatíveis é imediata
            \2[-] basta verificar se suas estruturas são idênticas
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Teorema: ROBDDs são únicos}

    \begin{block}{\textbf{Teorema 6.7}}
        A representação em ROBDD de uma função dada $\phi$ é unica. Isto é, sejam $B$ e $B^\prime$ dois ROBDDs com ordens compatíveis; se $B$ e $B^\prime$ representam a mesma função booleana, então eles têm estruturas idênticas.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Consequências da forma canônica}

    \scriptsize

    \begin{outline}
        \uncover<1->{
            \1 \textbf{Teste de equivalência semântica}. Se duas funções são representadas por OBDDs com ordens compatíveis, é possível decidir eficientemente se são equivalentes reduzindo-os e comparando sua estrutura;
        }
        
        \uncover<2->{
            \vspace{1em}
            
            \1 \textbf{Ausência de variáveis redundantes}. Se o valor de uma função booleana não depende de uma variável, então o ROBDD que a representa não contém tal variável;
        }
        
        \uncover<3->{
            \vspace{1em}
            
            \1 \textbf{Teste de validade}. Se uma função booleana é válida, seu ROBDD \underline{é igual} a $B_1$;
        }
        
        \uncover<4->{
            \vspace{1em}
            
            \1 \textbf{Teste de satisfação}. Se uma função booleana é satisfeita, então seu ROBDD \underline{não é igual} a $B_0$;
        }
        
        \uncover<5->{
            \vspace{1em}

            \1 \textbf{Teste de implicação}. Pode-se testar se uma função $\phi$ implica em outra $\psi$ calculando o ROBDD para $\phi \land \lnot{\psi}$; a implicação é verdadeira se e somente se este ROBDD é igual a $B_0$.
        }
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Impacto da escolha da ordenação}

    Considere a escolha da ordem de variáveis para a seguinte função booleana em CNF:
    $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land ... \land (p_{2n-1} \lor p_{2n})$

    \begin{outline}
        \small
        \1 Se a escolha for a ``\textit{ordem natural de ocorrência na fórmula}'' ($[p_1,p_2,p_3,...,,p_{2n-1},p_{2n}]$), o ROBDD terá $2n+2$ nós
        
        \vspace{1em}
        
        \1 Se a escolha for ``\textit{índices impares antes de índices pares}'' ($[p_1,p_3,p_5,...,p_{2n-1},p_2,p_4,p_6,...,p_{2n}]$), o ROBDD terá $2^{n+1}$ nós
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ordem ``natural'' para $n=3$}
    
    \scriptsize
    ROBDD para $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land (p_5 \land p_6)$ com a ordem de variáveis $[p_1,p_2,p_3,p_4,p_5,p_6]$
    
    \begin{figure}
    
        \begin{tikzpicture}
            [scale=0.9,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines, step=0.5] (0,0) grid (5,6);

            \node[rectangle, scale=0.7] (0) at (0.0, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (5.0, 0.0) {$1$};
            
            \node (p6) at (2.5, 1.0) {$p_6$};
            \node (p5) at (5.0, 2.0) {$p_5$};
            \node (p4) at (2.5, 3.0) {$p_4$};
            \node (p3) at (5.0, 4.0) {$p_3$};
            \node (p2) at (2.5, 5.0) {$p_2$};
            \node (p1) at (5.0, 6.0) {$p_1$};

            \draw[dashed, thick] (p1) to (p2);
            \draw[thick] (p1) to (p3);
            \draw[dashed, thick] (p2) to (0);
            \draw[thick] (p2) to (p3);
            \draw[dashed, thick] (p3) to (p4);
            \draw[thick] (p3) to (p5);
            \draw[dashed, thick] (p4) to (0);
            \draw[thick] (p4) to (p5);
            \draw[dashed, thick] (p5) to (p6);
            \draw[thick] (p5) to (1);
            \draw[dashed, thick] (p6) to (0);
            \draw[thick] (p6) to (1);
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ordem ``ímpares $\prec$ pares'' para $n=3$}

    \scriptsize
    ROBDD para $\phi \equiv (p_1 \lor p_2) \land (p_3 \lor p_4) \land (p_5 \land p_6)$ com a ordem de variáveis $[p_1,p_3,p_5,p_2,p_4,p_6]$
    
    \begin{figure}
    
        \begin{tikzpicture}
            [scale=0.8,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines, step=0.5] (0,0) grid (6,7);

            \node[rectangle, scale=0.7] (0) at (0.5, 0.0) {$0$};
            \node[rectangle, scale=0.7] (1) at (6.0, 0.0) {$1$};
            
            \node (p1) at (3.25, 6.5) {$p_1$};
            \node (p3a) at (1.5, 5.5) {$p_3$};
            \node (p3b) at (5.0, 5.5) {$p_3$};
            \node (p5a) at (0.5, 4.5) {$p_5$};
            \node (p5b) at (2.5, 4.5) {$p_5$};
            \node (p5c) at (4.0, 4.5) {$p_5$};
            \node (p5d) at (6.0, 4.5) {$p_5$};
            \node (p2a) at (0.0, 3.3) {$p_2$};
            \node (p2b) at (1.0, 3.3) {$p_2$};
            \node (p2c) at (2.0, 3.3) {$p_2$};
            \node (p2d) at (3.0, 3.3) {$p_2$};
            \node (p4a) at (2.85, 1.7) {$p_4$};
            \node (p4b) at (5.25, 1.7) {$p_4$};
            \node (p6) at (4.0, 0.7)  {$p_6$};
            
            \draw[dashed, thick] (p1) to (p3a);
            \draw[thick] (p1) to (p3b);
            \draw[dashed, thick] (p3a) to (p5a);
            \draw[thick] (p3a) to (p5b);
            \draw[dashed, thick] (p3b) to (p5c);
            \draw[thick] (p3b) to (p5d);
            \draw[dashed, thick] (p5a) to (p2a);
            \draw[thick] (p4a) to (p6);
            \draw[dashed, thick] (p4b) to (0);
            \draw[thick] (p4b) to (1);
            \draw[thick] (p5a) to (p2b);
            \draw[dashed, thick] (p5b) to (p2c);
            \draw[thick] (p5b) to (p2d);
            \draw[dashed, thick, bend left=10] (p5c) to (p4a);
            \draw[thick] (p5c) to (p4b);
            \draw[dashed, thick, bend right=10] (p5d) to (p6);
            \draw[thick] (p5d) to (1);
            \draw[dashed, thick] (p4a) to (0);
            \draw[dashed, thick] (p6) to (0);
            \draw[thick] (p6) to (1);
            
            \draw[dashed, thick] (p2a) to (0);
            \draw[thick] (p2a) to (p4a);
            \draw[dashed, thick] (p2b) to (0);
            \draw[thick, bend right=10] (p2b) to (p4b);
            \draw[dashed, thick] (p2c) to (0);
            \draw[thick, bend left=10] (p2c) to (p6);
            \draw[dashed, thick] (p2d) to (0);
            \draw[thick] (p2d) to (1);
            
        \end{tikzpicture}

    \end{figure}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Escolha da ordenação}

    \begin{outline}
        \1 A sensibilidade do tamanho de um ROBDD à ordem escolhida é o preço pago pelas facilidades obtidas
        
        \vspace{1em}
        
        \1 Encontrar a ordem ótima também é um problema computacional caro
            \2[-] mas há heurísticas para ordens razoavelmente boas
            \2[-] tipicamente, agrupa-se as variáveis com interações mais fortes
            
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{ROBDDs como representação}

    \begin{outline}
        \1 RODDBs permitem representações compactas de certas classes de funções booleanas
            \2[-] que seriam exponenciais em outros formatos/representações
            
        \vspace{1em}
        
        \1 Por outro lado, não se pode realizar as operações $\land$ e $\lor$ da forma ``inocente'' anteriormente estudada
            \2[-] elas podem introduzir ocorrências múltiplas de variáveis
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Operações eficientes com ROBDDs}

    Utilizando ROBDDs, é possível fazer operações de forma eficiente:
    
    \begin{outline}
        \1 \textbf{Redução}. A redução é o cerne da utilização séria de ROBDDs
            \2[-] consistindo da aplicação eficiente das simplificações C1-C3
            
        \1 \textbf{Aplicação}. A aplicação permite realizar as operações lógicas $\land$, $\lor$ e $\lnot$ (via $\phi \oplus 1$)
            \2[-] mantendo o BDD ordenado e reduzido
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Estrutura de dados}

    Os algoritmos das operações com ROBDDs utilizam como estrutura de dados uma tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$, tal que:

    \small
    \begin{outline}
        \1 $\langle v,i_l,i_r \rangle$ representa um nó qualquer no ROBDD
            \2[-] {\small com uma variável $v$}
            \2[-] {\small e identificadores de seus nós-filhos $i_{l}$ (\textit{low}, pela linha pontilhada) e $i_{h}$ (\textit{high}, pela linha sólida)}
            
        \vspace{1em}
            
        \1 $i_v$ representa um inteiro positivo que serve como identificador único do nó da variável $v$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração dessa estrutura de dados}

    \begin{columns}[c]

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=1.0,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    % Índices
                    \node[draw=none, scale=0.5, emphasis, left=0 of 0] {$\#0$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of 1] {$\#1$};
                    \node[draw=none, scale=0.5, emphasis, left=0 of q1] {$\#2$};
                    \node[draw=none, scale=0.5, emphasis, above left=0 of r] {$\#3$};
                    \node[draw=none, scale=0.5, emphasis, right=0 of q2] {$\#4$};
                    \node[draw=none, scale=0.5, emphasis, above=0 of p] {$\#5$};
                    
                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \renewcommand{\arraystretch}{1.5}        
            \begin{table}
                \scriptsize
                \caption{Tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    $\langle 0,\textproc{null},\textproc{null} \rangle$ & $0$\\
                    $\langle 1,\textproc{null},\textproc{null} \rangle$ & $1$\\
                    $\langle q,0,1 \rangle$                             & $2$\\
                    $\langle r,0,1 \rangle$                             & $3$\\
                    $\langle q,3,1 \rangle$                             & $4$\\
                    $\langle p,2,4 \rangle$                             & $5$\\
                \end{tabular}
            \end{table}
            
    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Observações}

    Nos algoritmos apresentados a seguir, assume-se que:

    \begin{outline}
        \small
        \1 A tabela $T$ é uma variável global e $|T|$ é o número de linhas existentes nessa tabela

        \1 $T(\langle v,i_l,i_h \rangle) = \textproc{null}$ quando $(i_v, \langle v,i_l,i_h \rangle) \notin T$
        
        \1 $\textproc{lo}$ e $\textproc{hi}$ acessam os nós-filhos de um nó

        \1 $\textproc{id}$ acessa o identificador de um nó
        
        \1 $\textproc{var}$ acessa a variável de um nó
            
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de redução}

    \small
    Reduz um OBDD de maneira recorrente. Funciona assim:
    
    \begin{outline}[enumerate]
        \1 Percorre o OBDD de baixo para cima (busca em profundidade) atribuindo identificadores inteiros aos nós
        
        \1 Se o nó for terminal, atribui ou reutiliza o identificador (simplificação C1)
        
        \1 Se os identificadores dos filhos forem iguais, atribui ao nó esse mesmo identificador (simplificação C2)
        
        \1 Se existir outro nó com os mesmos filhos, atribui seu identificador ao nó (simplificação C3)
        
        \1 Caso contrário, atribui ao nó o próximo inteiro livre
        
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{getnode}}
    \begin{algorithm}[H]
        \scriptsize
        \begin{algorithmic}[1]
            \Require recebe uma variável e os identificadores dos nós canônicos de seus filhos
            \Ensure devolve o identificador do nó canônico da variável
            \Function{getnode}{$v,i_l,i_h$}
                \If{$v \notin \{0,1\}$}
                    \If{$i_l = i_h$} \Comment simplificação C2
                        \State \Return $i_l$
                    \EndIf
                \EndIf
            
                \State $i \gets T(\langle v,i_l,i_h \rangle)$
                \If{$i = \textproc{NULL}$} \Comment simplificações C1/C3
                    \State $i = |T|$
                    \State $T \gets T \cup \{(i, \langle v,i_l,i_h \rangle)\}$
                \EndIf
                \State \Return $i$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{reduce}}
    \begin{algorithm}[H]
        \scriptsize
        \begin{algorithmic}[1]
            \Require recebe o nó raiz de um diagrama a ser reduzido
            \Ensure devolve o identificador do nó canônico (isto é, do diagrama reduzido)
            \Function{reduce}{$n$}
                \If{$n \in \{0,1\}$} \Comment simplificação C1
                    \State \Return \Call{getnode}{\Call{var}{n},\textproc{null},\textproc{null}}
                \EndIf

                \State $i_n \gets T(\langle \Call{var}{n},\Call{id}{\Call{lo}{n}},\Call{id}{\Call{hi}{n}} \rangle)$
                \If{$i_n = \textproc{NULL}$}
                    \State $i_l \gets \Call{reduce}{\Call{lo}{n}}$
                    \State $i_h \gets \Call{reduce}{\Call{hi}{n}}$                

                    \State $i_n \gets \Call{getnode}{\Call{var}{n},i_l,i_h}$ \Comment simplificação C3
                \EndIf

                \State \Return $i_n$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração do algoritmo de redução}

    \begin{columns}[c]

        \column{0.5\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=1.0,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (6,6);
                    \only<-21>{\node (p) at (3.0, 4.0) {$p$};}
                    \node (q1) at (1.5, 2.0) {$q$};
                    \only<-19>{\node (q2) at (4.5, 2.0) {$q$};}
                    \node[rectangle, scale=0.7] (0a) at (0.5, 0.0) {$0$};
                    \node[rectangle, scale=0.7] (1a) at (2.5, 0.0) {$1$};
                    \only<-14>{\node[rectangle, scale=0.7] (0b) at (3.5, 0.0) {$0$};}
                    \only<-17>{\node[rectangle, scale=0.7] (1b) at (5.5, 0.0) {$1$};}
                    
                    \only<-21>{\draw[dashed, thick] (p) to (q1);}
                    \only<-19>{\draw[thick] (p) to (q2);}
                    \draw[dashed, thick] (q1) to (0a);
                    \draw[thick] (q1) to (1a);
                    \only<-14>{\draw[dashed, thick] (q2) to (0b);}
                    \only<-17>{\draw[thick] (q2) to (1b);}
                    
                    \uncover<2-21>{
                        \node[emphasis] (p) at (3.0, 4.0) {$p$};
                    }
                    \uncover<3-10>{
                        \node[emphasis] (q1) at (1.5, 2.0) {$q$};
                        \draw[dashed, thick, emphasis] (p) to (q1);
                    }
                    \uncover<4-5>{
                        \node[rectangle, scale=0.7, emphasis] (0a) at (0.5, 0.0) {$0$};
                        \draw[dashed, thick, emphasis] (q1) to (0a);
                    }
                    \uncover<5->{
                        \node[draw=none, scale=0.5, emphasis, left=0 of 0a] {$\#0$};
                    }
                    \uncover<7-8>{
                        \node[rectangle, scale=0.7, emphasis] (1a) at (2.5, 0.0) {$1$};
                        \draw[thick, emphasis] (q1) to (1a);
                    }
                    \uncover<8->{
                        \node[draw=none, scale=0.5, emphasis, left=0 of 1a] {$\#1$};
                    }
                    \uncover<10->{
                        \node[draw=none, scale=0.5, emphasis, left=0 of q1] {$\#2$};
                    }
                    \uncover<12-19>{
                        \node[emphasis] (q2) at (4.5, 2.0) {$q$};
                        \draw[thick, emphasis] (p) to (q2);
                    }
                    \uncover<13-14>{
                        \node[rectangle, scale=0.7, emphasis] (0b) at (3.5, 0.0) {$0$};
                        \draw[dashed, thick, emphasis] (q2) to (0b);
                    }
                    \uncover<14>{
                        \node[draw=none, scale=0.5, emphasis, right=0 of 0b] {$\#0$};
                    }
                    \uncover<15-19>{
                        \draw[dashed, thick] (q2) to (0a);
                    }
                    \uncover<16-17>{
                        \node[rectangle, scale=0.7, emphasis] (1b) at (5.5, 0.0) {$1$};
                        \draw[thick, emphasis] (q2) to (1b);
                    }
                    \uncover<17-17>{
                        \node[draw=none, scale=0.5, emphasis, right=0 of 1b] {$\#1$};
                    }
                    \uncover<18-19>{
                        \draw[thick] (q2) to (1a);
                    }
                    \uncover<19-19>{
                        \node[draw=none, scale=0.5, emphasis, right=0 of q2] {$\#2$};
                    }
                    \uncover<20-21>{
                        \draw[thick, bend left] (p) to (q1);
                    }
                    \uncover<21-21>{
                        \node[draw=none, scale=0.5, emphasis, left=0 of p] {redundante};
                    }
                    \only<22>{}
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \renewcommand{\arraystretch}{1.5}        
            \begin{table}
                \scriptsize
                \caption{Tabela $T: \langle v,i_l,i_h \rangle \mapsto i_v$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    \uncover<5->{
                        $\langle 0,\textproc{null},\textproc{null} \rangle$ & $0$
                    }\\
                    \uncover<8->{
                        $\langle 1,\textproc{null},\textproc{null} \rangle$ & $1$
                    }\\
                    \uncover<10->{
                        $\langle q,0,1 \rangle$ & $2$
                    }\\
                \end{tabular}
            \end{table}
            
    \end{columns}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de aplicação}

    \small
    Obtém o resultado de $B_\phi~op~B_\psi$, sendo $op$ uma operação booleana ($\land$, $\lor$, $\oplus$ ou $\lnot$ via $B_\phi \oplus 1$). Funciona assim:

    \begin{outline}[enumerate]
        \1 inicia com a variável $v$ de maior ordem (mais à esquerda na lista de ordenação)
        \1 divide o problema em dois subproblemas, dependendo de $v$ ser $0$ ou $1$, e resolve de maneira recorrente
        \1 nas folhas, aplica a operação booleana $op$ diretamente
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Dependência conceitual}

    \centering
    O algoritmo para a aplicação de operações booleanas entre OBDDs utiliza o conceito da \underline{Expansão de Shannon}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: restrições}

    \begin{block}{\textbf{Definição 6.9}}
        Sejam $\phi$ uma expressão booleana e $p$ uma variável. Denotamos por $\phi[0/p]$ a expressão booleana obtida substituindo-se todas as ocorrências de $p$ em $\phi$ por $0$. A expressão $\phi[1/p]$ é definida de maneira semelhante. As expressões $\phi[0/p]$ e $\phi[1/p]$ são chamadas de \underline{restrições} em $\phi$ com relação à variável $p$.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplos de restrições}

    Para $\phi \equiv p \land (q \lor \lnot{p})$ tem-se:

    \begin{outline}
        \1 $\phi[0/p]$ é igual a $0 \land (q \lor \lnot{0})$
            \2[-] que é semanticamente equivalente a $0$
            
        \vspace{1em}
        
        \1 $\phi[1/p]$ é igual a $1 \land (q \lor \lnot{1})$
            \2[-] que é semanticamente equivalente a $q$
            
        \vspace{1em}
        
        \1 $\phi[0/q]$ é igual a $p \land (0 \lor \lnot{p})$
            \2[-] que é semanticamente equivalente a $\bot$
            
        \vspace{1em}
        
        \1 $\phi[1/q]$ é igual a $p \land (1 \lor \lnot{p})$
            \2[-] que é semanticamente equivalente a $p$
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Uso das restrições}

    \begin{outline}
        \1 As restrições permitem executar recorrências em expressões booleanas decompondo-as em expressões mais simples
        
        \vspace{1em}
        
        \1 Se $p$ é uma variável em $\phi$, então $\phi$ é equivalente a $\lnot{p} \land \phi[0/p] \lor p \land \phi[1/p]$
            \2[-] facilmente verificável
            \2[-] fazendo $p = 0$ resulta em $\phi[0/p]$
            \2[-] fazendo $p = 1$ resulta em $\phi[1/p]$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Lema: Expansão de Shannon}

    \begin{block}{\textbf{Lema 6.10}}
        Para todas as expressões booleanas $\phi$ e todas as variáveis $p$ (mesmo as que não ocorrem em $\phi$), tem-se a chamada \underline{Expansão de Shannon}:\\[1em]
        $\phi \equiv \lnot{p} \land \phi[0/p] \lor p \land \phi[1/p]$
    \end{block}

\end{frame}
%-------------------------------------------




%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{apply}}
    \begin{algorithm}[H]
        \tiny
        \begin{algorithmic}[1]
            \Require recebe um operador lógico e os nós raízes de dois diagramas com ordens compatíveis
            \Ensure devolve o identificador do nó canônico do resultado da operação
            \Function{apply}{$op,n_\phi,n_\psi$}
                \State $v_\phi \gets \Call{var}{n_\phi}$
                \State $v_\psi \gets \Call{var}{n_\psi}$
                
                \If{$(v_\phi \in \{0,1\}) \land (v_\psi \in \{0,1\})$} \Comment se ambos são nós terminais
                    \State $r \gets n_\phi~op~n_\psi$ \Comment aplica a operação diretamente
                    \State \Return $\Call{getnode}{r,\textproc{null},\textproc{null}}$
                \EndIf
                
                \If{$v_\phi = v_\psi$} \Comment se têm a mesma variável
                    \State $i_l \gets \Call{apply}{op,\Call{lo}{n_\phi},\Call{lo}{n_\psi}}$
                    \State $i_h \gets \Call{apply}{op,\Call{hi}{n_\phi},\Call{hi}{n_\psi}}$
                    \State \Return $\Call{getnode}{v_\phi,i_l,i_h}$
                \Else
                    \If{$v_\phi \prec v_\psi$} \Comment se $v_\phi$ ocorre antes de $v_\psi$
                        \State $i_l \gets \Call{apply}{op,\Call{lo}{n_\phi},n_\psi}$
                        \State $i_h \gets \Call{apply}{op,\Call{hi}{n_\phi},n_\psi}$
                        \State \Return $\Call{getnode}{v_\phi,i_l,i_h}$
                    \Else \Comment se $v_\phi$ ocorre após $v_\psi$
                        \State $i_l \gets \Call{apply}{op,n_\phi,\Call{lo}{n_\psi}}$
                        \State $i_h \gets \Call{apply}{op,n_\phi,\Call{hi}{n_\psi}}$
                        \State \Return $\Call{getnode}{v_\psi,i_l,i_h}$
                    \EndIf
                \EndIf
                
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------






























%
%=======================================================================
% Slides removidos/escondidos
%=======================================================================
%
\iffalse
%-------------------------------------------
\begin{frame}{operador \textproc{ite}}

    \begin{block}{\textbf{Definição auxiliar\footnote{não consta do livro}}}
        Com base nessa equivalência, definimos o operador \textproc{ite} (de \textit{if-then-else}) como:\\[1em]
        $\textproc{ite}(p,\phi,\phi^{\prime}) = (p \land \phi) \lor (\lnot{p} \land \phi^{\prime})$
        \\[1em]
        Dessa forma, \textproc{ite} é verdadeiro se a variável $p$ e a expressão $\phi$ são verdadeiros, ou se a variável $p$ é falsa e a expressão $\phi^{\prime}$ é verdadeira.
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Uso do operador \textproc{ite}}

    O operador $\textproc{ite}(p,\phi,\phi^{\prime}) = (p \land \phi) \lor (\lnot{p} \land \phi^{\prime})$ permite expressar qualquer operador da gramática da Lógica Proposicional:

    \small
    \begin{outline}
        \1 $\lnot{p} = \textproc{ite}(\textcolor{emphasis}{p},\lnot{\textcolor{emphasis}{1}},\lnot{\textcolor{emphasis}{0}}) = \textproc{ite}(p,0,1)$
        
        \1 $p \land q = \textproc{ite}(\textcolor{emphasis}{p},\textcolor{emphasis}{1} \land q,\textcolor{emphasis}{0} \land q) = \textproc{ite}(p,q,0) = \textproc{ite}(p,\textproc{ite}(\textcolor{emphasis}{q},\textcolor{emphasis}{1},\textcolor{emphasis}{0}),0)$
        
        \1 $p \lor q = \textproc{ite}(\textcolor{emphasis}{p},\textcolor{emphasis}{1} \lor q,\textcolor{emphasis}{0} \lor q) = \textproc{ite}(p,1,q) = \textproc{ite}(p,1,\textproc{ite}(\textcolor{emphasis}{q},\textcolor{emphasis}{1},\textcolor{emphasis}{0}))$
        
        \1 $p \to q = \textproc{ite}(\textcolor{emphasis}{p},\textcolor{emphasis}{1} \to q,\textcolor{emphasis}{0} \to q) = \textproc{ite}(p,q,1) = \textproc{ite}(p,\textproc{ite}(\textcolor{emphasis}{q},\textcolor{emphasis}{1},\textcolor{emphasis}{0}),1)$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Forma normal condicional}

    \begin{center}
        \shadowbox{
            \begin{minipage}[h]{1.0\columnwidth}
                \noindent\justifying
                Uma expressão booleana está na forma normal condicional se e somente se ela contém apenas constantes, o operador condicional \textproc{ite} e variáveis sendo testadas por esse operador
            \end{minipage}
        }
    \end{center}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Exemplos na forma e fora dela}

    \small
    \begin{outline}
        \1 A expressão $\textproc{ite}(p, \textproc{ite}(q, 1, \textcolor{emphasis}{r}), \textproc{ite}(q, 1, 0))$ \underline{não está} na forma normal condicional
            \2[-] a variável $\textcolor{emphasis}{r}$ ainda não está sendo testada condicionalmente

        \vspace{1em}
            
        \1 A expressão $\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(r, 1, 0)), \textproc{ite}(q, 1, 0))$ \underline{está} na forma normal condicional        
            \2[-] todas as variáveis estão sendo testadas condicionalmente
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Conversão para a forma condicional}

    Toda expressão booleana pode ser convertida indutivamente para a forma normal condicional da seguinte maneira:

    \begin{outline}
        \1 Se $\phi$ só contém variáveis de teste, ela já está na forma normal condicional
        
        \vspace{1em}
        
        \1 Senão, enquanto houver uma variável $p \in \phi$ que não seja teste, reescreva $\phi$ como $\textproc{ite}(p, \phi[1/p], \phi[0/p])$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Por exemplo}

    \begin{outline}
        \0 Conversão de $(p \lor q) \land (q \lor r)$ para a forma normal conditional
        \1[=] $\textproc{ite}(\textcolor{emphasis}{p}, (\textcolor{emphasis}{1} \lor q) \land (q \lor r), (\textcolor{emphasis}{0} \lor q) \land (q \lor r))$
        \1[=] $\textproc{ite}(p, q \lor r, q)$
        \1[=] $\textproc{ite}(p, \textproc{ite}(\textcolor{emphasis}{q}, \textcolor{emphasis}{1} \lor r, \textcolor{emphasis}{0} \lor r), \textproc{ite}(\textcolor{emphasis}{q}, \textcolor{emphasis}{1}, \textcolor{emphasis}{0}))$
        \1[=] $\textproc{ite}(p, \textproc{ite}(q, 1, r), \textproc{ite}(q, 1, 0))$
        \1[=] $\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(\textcolor{emphasis}{r}, \textcolor{emphasis}{1}, \textcolor{emphasis}{0})), \textproc{ite}(q, 1, 0))$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Forma condicional e árvore de decisão}

    A estrutura de recorrência da forma normal condicional:
    $$\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(r, 1, 0)), \textproc{ite}(q, 1, 0))$$
    da expressão booleana $(p \lor q) \land (q \lor r)$ é a mesma da sua arvore de decisão binária

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração do argumento anterior}
    
    \begin{columns}[c]
        \column{0.5\textwidth}

            \begin{figure}
            
                \caption{\scriptsize Árvore de Decisão Binária da expressão: $(p \lor q) \land (q \lor r)$}
                
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (p) at (4.25, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (6.0, 4.5) {$q$};
                    \node[rectangle, scale=0.7] (1a) at (1.5, 3.0) {$1$};
                    \node (r) at (3.5, 2.0) {$r$};
                    \node[rectangle, scale=0.7] (1b) at (5.0, 3.0) {$1$};
                    \node[rectangle, scale=0.7] (0a) at (7.0, 3.0) {$0$};
                    \node[rectangle, scale=0.7] (1c) at (2.5, 0.0) {$1$};
                    \node[rectangle, scale=0.7] (0b) at (4.5, 0.0) {$0$};

                    \draw[thick] (p) to (q1);
                    \draw[dashed, thick] (p) to (q2);
                    \draw[thick] (q1) to (1a);
                    \draw[dashed, thick] (q1) to (r);
                    \draw[thick] (q2) to (1b);
                    \draw[dashed, thick] (q2) to (0a);
                    \draw[thick] (r) to (1c);
                    \draw[dashed, thick] (r) to (0b);
                \end{tikzpicture}

            \end{figure}

        \column{0.5\textwidth}
        
            \begin{figure}
            
                \caption{\scriptsize Estrutura recorrente da forma condicional: $\textproc{ite}(p, \textproc{ite}(q, 1, \textproc{ite}(r, 1, 0)), \textproc{ite}(q, 1, 0))$}
            
                \begin{tikzpicture}
                    [scale=0.8,auto=left,
                        every node/.style={minimum height=4mm, draw=none, align=center, text depth = 0pt, transform shape}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);

                    \node (p) at (4.25, 6.0) {$\textproc{ite}(p,\phi,\phi^{\prime})$};
                    \node (q1) at (2.5, 4.5) {$\textproc{ite}(q,\phi,\phi^{\prime})$};
                    \node (q2) at (6.0, 4.5) {$\textproc{ite}(q,\phi,\phi^{\prime})$};
                    \node[rectangle, scale=0.7] (1a) at (1.5, 3.0) {$1$};
                    \node (r) at (3.5, 2.0) {$\textproc{ite}(r,\phi,\phi^{\prime})$};
                    \node[rectangle, scale=0.7] (1b) at (5.0, 3.0) {$1$};
                    \node[rectangle, scale=0.7] (0a) at (7.0, 3.0) {$0$};
                    \node[rectangle, scale=0.7] (1c) at (2.5, 0.0) {$1$};
                    \node[rectangle, scale=0.7] (0b) at (4.5, 0.0) {$0$};

                    \draw[dotted, thick] (p) -- (q1) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (p) -- (q2) node[midway, scale=0.5] {$\phi^{\prime}$};
                    \draw[dotted, thick] (q1) -- (1a) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (q1) -- (r) node[midway, scale=0.5] {$\phi^{\prime}$};
                    \draw[dotted, thick] (q2) -- (1b) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (q2) -- (0a) node[midway, scale=0.5] {$\phi^{\prime}$};
                    \draw[dotted, thick] (r) -- (1c) node[midway, scale=0.5] {$\phi$};
                    \draw[dotted, thick] (r) -- (0b) node[midway, scale=0.5] {$\phi^{\prime}$};
                \end{tikzpicture}

            \end{figure}        
        
    \end{columns}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Estrutura de dados}

    A estrutura de dados para representar um ROBDD é composta de:

    \begin{outline}
        \1 Uma tabela $T: n \mapsto \langle v,t,f \rangle$
            \2[-] que associa a cada identificador $n$ um nó com variável de teste $v$, filho esquerdo $t$ e filho direito $f$
        
        \vspace{1em}
        
        \1 Uma tabela inversa $T^{-1}: \langle v,t,f \rangle \mapsto n$
            \2[-] que associa nós em identificadores
            \2[-] devido ao compartilhamento de sub-grafos
            \2[-] usada para garantir que os diagramas sejam reduzidos
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Ilustração dessa estrutura de dados}

    \setlength{\tabcolsep}{2pt}
    \renewcommand{\arraystretch}{1.5}        

    \begin{columns}[c]

        \column{0.2\textwidth}
            
            \begin{figure}
            
                \begin{tikzpicture}
                    [scale=0.7,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (8,6);
                  
                    \node (p) at (4.0, 6.0) {$p$};
                    \node (q1) at (2.5, 4.5) {$q$};
                    \node (q2) at (5.5, 4.5) {$q$};
                    \node (r) at (4.0, 3.0) {$r$};
                    
                    \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (1) at (5.5, 1.0) {$1$};

                    \draw[dashed, thick] (p) to (q1);
                    \draw[thick] (p) to (q2);
                    \draw[dashed, thick] (q1) to (0);
                    \draw[thick, bend right] (q1) to (1);
                    \draw[dashed, thick] (q2) to (r);
                    \draw[thick] (q2) to (1);
                    \draw[dashed, thick] (r) to (0);
                    \draw[thick] (r) to (1);
                    
                \end{tikzpicture}

            \end{figure}

        \column{0.35\textwidth}
        
            \begin{table}
                \scriptsize
                \caption{\scriptsize Tabela $T: n \mapsto \langle v,t,f \rangle$}
                \begin{tabular}{c|c}
                    $n$ & $T(n)$\\
                    \hline
                    $0$ & $\langle p_{6},\textproc{null},\textproc{null} \rangle$\\
                    $1$ & $\langle p_{6},\textproc{null},\textproc{null} \rangle$\\
                    $2$ & $\langle p,3,4 \rangle$\\
                    $3$ & $\langle q,0,1 \rangle$\\
                    $4$ & $\langle q,5,1 \rangle$\\
                    $5$ & $\langle r,0,1 \rangle$\\
                \end{tabular}
            \end{table}

        \column{0.45\textwidth}
        
            \begin{table}
                \scriptsize
                \caption{\scriptsize Tabela $T^{-1}: \langle v,t,f \rangle \mapsto n$}
                \begin{tabular}{c|c}
                    $\langle v,t,f \rangle$ & $T^{-1}(\langle v,t,f \rangle)$\\
                    \hline
                    $\langle p_{6},\textproc{null},\textproc{null} \rangle$ & $0$\\
                    $\langle p_{6},\textproc{null},\textproc{null} \rangle$ & $1$\\
                    $\langle p,3,4 \rangle$                               & $2$\\
                    $\langle q,0,1 \rangle$                               & $3$\\
                    $\langle q,5,1 \rangle$                               & $4$\\
                    $\langle r,0,1 \rangle$                               & $5$\\
                \end{tabular}
            \end{table}
            
    \end{columns}

    \vspace{-1em}
    
    \begin{center}
        \ovalbox{
            \begin{minipage}[h]{\columnwidth}
                \noindent\scriptsize\justifying
                $p_6$: variável auxiliar usada nos nós terminais para manter a uniformidade da tabela
            \end{minipage}
        }
    \end{center}    
    
\end{frame}
%-------------------------------------------
    
%-------------------------------------------
\begin{frame}{Observações}

    Nos algoritmos estudados a seguir, assume-se que:

    \begin{outline}
        \1 $T(n) = T^{-1}(\langle v,t,f \rangle) = \textproc{null}$ sempre que $(n, \langle v,t,f \rangle) \notin T$
        
        \vspace{1em}
        
        \1 A tabela $T$ é uma variável global e $|T|$ é o número de entradas existentes nessa tabela
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de inicialização}

    Cria a tabela $T$ de um ROBDD. Funciona assim:

    \small
    \begin{outline}
        \1 Recebe uma entrada $m$ indicando o número máximo de variáveis existentes na expressão booleana
        
        \vspace{1em}
        
        \1 Inicia a tabela $T$ com duas tuplas especiais
            \2[-] representando os nós terminais $0$ e $1$
            \2[-] para garantir uniformidade, associa os nós terminais à uma variável auxiliar $p_{m+1}$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \textproc{INIT}}
    %\scriptsize
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \Procedure{INIT}{$T,m$}
                \State $T \gets \{(0, \langle m+1, \textproc{null},\textproc{null} \rangle\}),$\par
                \hskip\algorithmicindent $\{(1, \langle m+1, \textproc{null}, \textproc{null} \rangle\})$
            \EndProcedure
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de inserção de nós}

    Insere um nó em um ROBDD, mantendo-o reduzido e ordenado. Funciona assim:

    \small
    \begin{outline}
        \1 Recebe como entrada uma variável $v$ e os identificadores de seus filhos $t$ e $f$

        \vspace{0.5em}

        \1 Se o nó $v$ for redundante ($t = f$), devolve imediatamente o identificador do nó filho ($t$)

        \vspace{0.5em}
        
        \1 Caso o nó $v$ já tenha sido criado, devolve seu identificador
        
        \vspace{0.5em}
        
        \1 Caso o nó $v$ seja novo, cria-o e devolve o identificador
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \texttt{INS}}
    \scriptsize
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \Function{INS}{$T,v,t,f$}
                \If{$t = f$}
                    \State \Return $t$
                \EndIf
                \State $n \gets T^{-1}(\langle v,t,f \rangle)$
                \If{$n = \textproc{null}$}
                    \State $n \gets |T|$
                    \State $T \gets T \cup \{(n, \langle v, t, f \rangle)\}$
                \EndIf
                \State \Return $n$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Algoritmo de construção de ROBDDs}

    Constrói um ROBDD a partir de uma expressão em forma normal condicional. Funciona assim:

    \small
    \begin{outline}
        \1 Recebe como entrada uma variável $v$ e os identificadores de seus filhos $t$ e $f$

        \vspace{0.5em}

        \1 Se o nó $v$ for redundante ($t = f$), devolve imediatamente o identificador do nó filho ($t$)

        \vspace{0.5em}
        
        \1 Caso o nó $v$ já tenha sido criado, devolve seu identificador
        
        \vspace{0.5em}
        
        \1 Caso o nó $v$ seja novo, cria-o e devolve o identificador
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Pseudocódigo de \texttt{BUILD}}
    \scriptsize
    \begin{algorithm}[H]
        \begin{algorithmic}[1]
            \Function{BUILD}{$\textproc{ite}(v,\phi_{t},\phi_{f})$}
                \If{$\phi_{t},\phi_{f} \in \{0,1\}$}
                    \State \Return $\Call{INS}{v,\phi_{t},\phi_{f}}$
                \EndIf
                \If{$\phi_{f} \in \{0,1\}$}
                    \State \Return $\Call{INS}{v,\Call{BUILD}{\phi_{t}},\phi_{f}}$
                \EndIf
                \If{$\phi_{t} \in \{0,1\}$}
                    \State \Return $\Call{INS}{v,\phi_{t},\Call{BUILD}{\phi_{f}}}$
                \EndIf
                \State \Return $\Call{INS}{v,\Call{BUILD}{\phi_{t}},\Call{BUILD}{\phi_{f}}}$
            \EndFunction
        \end{algorithmic}
    \end{algorithm}

\end{frame}
%-------------------------------------------
\fi

\end{document}