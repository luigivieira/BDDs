\providecommand\classopts{}
\expandafter\documentclass\expandafter[table, usenames, svgnames, dvipsnames,14pt, \classopts]{beamer}
\usetheme[everytitleformat=regular,frametitleformat=lowercase,progressbar=frametitle,numbering=fraction]{m} % load the metropolis theme
\usefonttheme[onlymath]{serif}

\usepackage[portuguese]{babel} % For writing in Portuguese
\usepackage[utf8]{inputenc} % For using unicode characters (easier with accents)
\usepackage{outlines} % For labeled itemize/enumerate blocks
\usepackage{fancybox} % For drawing fancy boxes
\usepackage{ragged2e} % For justifying text
\usepackage{multirow} % For spanning multiple rows in a table
\usepackage{caption}  % For custom captions in tables and figures
\captionsetup{labelformat=empty}

\usepackage{tikz-qtree} % For the graphs
\usetikzlibrary{shapes.arrows,trees,positioning}

\usepackage{amsmath} % For math symbols
\boldmath

\usepackage{tabularx} % For creating tables with data centered in cells
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\title{Diagramas de Decisão Binários (DDBs)}
\date{\today}
\author{Luiz Carlos Vieira}
\institute{Instituto de Matemática e Estatística da Universidade de São Paulo}

% definition symbol
\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

% Image's path
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\graphicspath{{./images/}}

\setbeamerfont{footnote}{size=\tiny}

\begin{document}
\maketitle

%-------------------------------------------
\begin{frame}{Conteúdo}

    \begin{outline}
        \1 Representação de Funções Booleanas
            \2[-] fórmulas proposicionais e tabelas-verdade
            \2[-] diagramas de decisão binários (DDBs)
            \2[-] diagramas de decisão binários ordenados (DDBOs)

        \vspace{1em}
            
        \1 Algoritmos para DDBOs Reduzidos
            \2[-] algoritmo \texttt{reduzir}
            \2[-] algoritmo \texttt{aplicar}
            \2[-] algoritmo \texttt{restringir}
            \2[-] algoritmo \texttt{existe}
    \end{outline}

\end{frame}
%-------------------------------------------

%===========================================
\section{Representação de Funções Booleanas}
%===========================================

%-------------------------------------------
\begin{frame}{Funções booleanas}

    \begin{outline}
        \1 Parte do formalismo descritivo de sistemas de \textit{hardware} e \textit{software}

        \vspace{1em}
            
        \1 Que precisa ser representado computacionalmente de forma eficiente
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: variáveis booleanas}

    \begin{block}{\textbf{Definição 6.1(a)}}
        Uma variável booleana $x$ é uma variável que só pode assumir os valores $0$ e $1$. Denotamos variáveis booleanas por $x_1$, $x_2$, $\cdots$, e $x$, $y$ e $z$, $\cdots$
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: funções booleanas}

    \begin{block}{\textbf{Definição 6.1(b)}}
        As seguintes funções são definidas no conjunto $\{0,1\}$:
        \\
        \begin{outline}
            \1 $\overline{0} \defeq 1$ e $\overline{1} \defeq 0$;
                
            \1 $x \cdot y \defeq 1$ se $x$ e $y$ têm valor $1$; caso contrário, $x \cdot y \defeq 0$;
            
            \1 $x + y \defeq 0$ se $x$ e $y$ têm valor $0$; caso contrário, $x + y \defeq 1$;
            
            \1 $x \oplus y \defeq 1$ se exatamente um entre $x$ e $y$ é igual a $1$; caso contrário, $x \oplus y \defeq 0$.
        \end{outline}        
        
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Funções e variáveis booleanas}

    \begin{outline}
        \1 Uma função booleana $f$ com $n$ variáveis é uma função de $\{0,1\}^n$ para $\{0,1\}$.
        
        \vspace{1em}
        
        \1 Escreve-se $f(x_1,x_2,\dots,x_n)$ ou $f(\mathcal{V})$ para indicar que uma representação sintática de $f$ só depende das variáveis booleanas em $\mathcal{V}$.
    \end{outline}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Alguns exemplos de funções booleanas}

    \begin{outline}[enumerate]
        \1 $f(x,y) \defeq x \cdot (y + \overline{x})$
            
        \vspace{1em}
            
        \1 $g(x,y) \defeq x \cdot y + (1 \oplus \overline{x})$

        \vspace{1em}

        \1 $h(x,y,z) \defeq x + y \cdot (x \oplus \overline{y})$

        \vspace{1em}

        \1 $k() \defeq 1 \oplus (0 \cdot \overline{1})$
    \end{outline}        

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{wffs e tabelas-verdade}

    As fórmulas proposicionais bem-formadas (\textit{wffs}) e as tabelas-verdade são duas formas de se representar funções booleanas

    \begin{outline}
        \1 \textbf{fórmulas proposicionais}:
            \2[-] $\land$ denota $\cdot$
            \2[-] $\lor$ denota $+$
            \2[-] $\lnot$ denota $\bar{~}$
            \2[-] e $\top$ e $\bot$ denotam, respectivamente, $1$ e $0$
        
        \vspace{1em}
        
        \1 \textbf{tabelas-verdade}: representam funções booleanas de maneira óbvia
    \end{outline}        
            
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Tabelas-verdade de funções booleanas}

    \begin{columns}[c]
        \column{0.5\textwidth}
            \begin{center}
                \begin{table}
                    \caption{Tabela-verdade da função booleana $f(x,y) \defeq \overline{x + y}$}
                    \vspace{1em}
                    \begin{tabular}{cc|c}
                        $x$ & $y$ & $f(x,y)$\\
                        \hline
                        $1$ & $1$ & $0$\\
                        $0$ & $1$ & $0$\\
                        $1$ & $0$ & $0$\\
                        $0$ & $0$ & $1$\\
                    \end{tabular}
                \end{table}
            \end{center}

        \column{0.5\textwidth}
            \begin{center}
                \begin{table}
                    \caption{Tabela-verdade da fórmula proposicional $\phi \equiv \lnot(p \lor q)$}
                    \vspace{1em}
                    \begin{tabular}{cc|c}
                        $p$ & $q$ & $\phi$\\
                        \hline
                        $V$ & $V$ & $F$\\
                        $F$ & $V$ & $F$\\
                        $V$ & $F$ & $F$\\
                        $F$ & $F$ & $V$\\
                    \end{tabular}
                \end{table}
            \end{center}
    \end{columns}
            
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Vantagens e desvantagens}

    \begin{center}
        \scriptsize
        
        \setlength{\tabcolsep}{2pt}
        \renewcommand{\arraystretch}{-1}
        \newcommand{\tabitem}{~~\llap{\textbullet}~}
        
        \begin{table}
            \caption{Há vantagens e desvantagens no uso de tabelas-verdade e fórmulas proposicionais para representar funções booleanas}
            \begin{tabular}{C{0.2\textwidth}|L{0.4\textwidth}L{0.4\textwidth}}
                & \multicolumn{1}{c}{\textbf{Tabelas-Verdade}} & \multicolumn{1}{c}{\textbf{Fórmulas Proposicionais}}\\
                \hline
                \textbf{Vantagens} &
                    \begin{itemize}
                        \item operações\footnote{verificação de satisfação e validade, e comparação de duas funções booleanas\label{operacoes}} simples
                    \end{itemize}
                    &
                    \begin{itemize}
                        \item representação compacta
                    \end{itemize}
                    \\
                            
                \textbf{Desvantagens} &
                    \begin{itemize}
                        \item ineficientes em espaço
                        \item computacionalmente intratável
                    \end{itemize}
                    &
                    \begin{itemize}
                        \item operações\footnotemark[1] difíceis
                        \item computacionalmente intratável
                    \end{itemize}
                    \\
            \end{tabular}
        \end{table}
    \end{center}
            
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Operações sobre funções booleanas}

    As operações $\cdot$, $+$, $\oplus$ e $\bar{~}$ sobre duas funções $f$ e $g$ são realizadas de forma simples:

    \begin{outline}
        \1 Com tabelas-verdade
            \2[-] operação diretamente aplicada a cada linha, adicionando variáveis se necessário
            \2[-] mas computacionalmente intratável ($2^n$ linhas)

        \vspace{1em}
            
        \1 Com fórmulas proposicionais
            \2[-] manipulação sintática da Lógica Proposicional
            \2[-] por exemplo: $f \cdot g$ e $f \oplus g$ são respectivamente $\phi \land \psi$ e $(\phi \land \lnot{\psi}) \lor (\lnot{\phi} \land \psi)$
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Utilizando formas normais}

    \begin{outline}
        \1 As formas normais facilitam em alguns aspectos
            \2[-] e dificultam em outros
        
        \vspace{1em}
        
        \1 Podem ser mais longas do que as fórmulas originais equivalentes não-normalizadas
    \end{outline}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Forma Normal Conjuntiva (\uppercase{CNF})}

    \begin{outline}
        \1 Facilita o teste de validade
            \2[-] busca de cláusula disjuntiva sem preposições complementares
            \2[-] teste de satisfação não é igualmente fácil
        
        \vspace{1em}
        
        \1 Facilita a operação de conjunção ($\cdot$)
            \2[-] se $f$ e $g$ são CNFs, o resultado de $f \cdot g$ é CNF
        
        \vspace{1em}
        
        \1 Dificulta as demais operações ($+$, $\oplus$ e $\bar{~}$)
            \2[-] distributividade recursiva para manter CNF
    \end{outline}

    \begin{center}
        \ovalbox{
            \begin{minipage}[h]{0.8\linewidth}
                \noindent\scriptsize
                A forma normal disjuntiva (DNF) -- disjunção de conjunções -- é dual com a CNF em relação a essas propriedades
            \end{minipage}
        }
    \end{center}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Resumo da eficiência das representações}

    \begin{center}
        \scriptsize
        
        \setlength{\tabcolsep}{1pt}
        \renewcommand{\arraystretch}{1.5}        
        
        \begin{table}
            \begin{tabular}{C{0.25\textwidth}|C{0.15\textwidth}*{5}{C{0.12\textwidth}}}
                & & \multicolumn{2}{c}{\textbf{teste de}} & \multicolumn{3}{c}{\textbf{operações booleanas}}\\[-3.5mm]
                \textbf{Representação de funções booleanas} & \textbf{compacta?} & \textbf{satisfação} & \textbf{validade} & $\cdot$ & $+$ & $\bar{~}$\\
                \hline
                \textbf{fórmulas proposicionais} & \textcolor{ForestGreen}{muitas vezes} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil} & \textcolor{ForestGreen}{fácil} & \textcolor{ForestGreen}{fácil} & \textcolor{ForestGreen}{fácil} \\
                \textbf{fórmulas CNF} & \textcolor{teal}{algumas vezes} & \textcolor{BrickRed}{difícil} & \textcolor{ForestGreen}{fácil} & \textcolor{ForestGreen}{fácil} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil}\\
                \textbf{fórmulas NDF} & \textcolor{teal}{algumas vezes} & \textcolor{ForestGreen}{fácil} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil} & \textcolor{ForestGreen}{fácil} & \textcolor{BrickRed}{difícil}\\
                \textbf{tabelas-verdade ordenadas} & \textcolor{BrickRed}{nunca} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil} & \textcolor{BrickRed}{difícil}\\
                \textbf{DDBOs reduzidos\footnote{que ainda serão explorados nessa aula}} & \textcolor{ForestGreen}{muitas vezes} & \textcolor{ForestGreen}{fácil} & \textcolor{ForestGreen}{fácil} & \textcolor{teal}{mais ou menos} & \textcolor{teal}{mais ou menos} & \textcolor{ForestGreen}{fácil}\\
            \end{tabular}
        \end{table}
    \end{center}
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Definição: Árvore de Decisão Binária Finita}

    \begin{block}{\textbf{Definição 6.3}}
        Seja $T$ uma árvore de decisão binária finita. Então $T$ determina \textit{uma única} função booleana das variáveis nos nós não-terminais da seguinte maneira:
        
        \begin{quotation}
        \noindent\small\justifying
        Dada uma atribuição de $0$'s e $1$'s às variáveis booleanas que ocorrem em $T$, começamos pela raiz de $T$ e pegamos a \textit{linha tracejada} sempre que o valor da variável no nó atual é $0$; caso contrário, percorremos a \textit{linha sólida}. O valor da função é o valor do nó terminal atingido.
        \end{quotation}
    \end{block}

\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Por exemplo}

    \begin{columns}[c]
        \column{0.4\textwidth}

            \begin{figure}

                \begin{tikzpicture}
                    [scale=1.0,auto=left,
                        every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                        every edge/.append style={draw=blue, thick}
                    ]
                    %\draw[help lines] (0,0) grid (6,6);
                  
                    \node (x) at (3.0, 5.0)  {$x$};
                    \node (y1) at (1.5, 3.0)  {$y$};
                    \node (y2) at (4.5, 3.0)  {$y$};
                    \node[rectangle, scale=0.7] (1) at (0.5, 1.0) {$1$};
                    \node[rectangle, scale=0.7] (0a) at (2.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (0b) at (3.5, 1.0) {$0$};
                    \node[rectangle, scale=0.7] (0c) at (5.5, 1.0) {$0$};

                    \draw[dashed, thick] (x) -- (y1);
                    \draw[thick] (x) -- (y2);
                    \draw[dashed, thick] (y1) -- (1);
                    \draw[thick] (y1) -- (0a);
                    \draw[dashed, thick] (y2) -- (0b);
                    \draw[thick] (y2) -- (0c);

                    % Animations
                    \uncover<3->{
                        \node[red] at (3.0, 5.0)  {$x$};
                    }
                    \uncover<4->{
                        \draw[dashed, thick, red] (x) -- (y1);
                    }
                    \uncover<5->{
                        \node[red] at (1.5, 3.0)  {$y$};
                        \draw[thick, red] (y1) -- (0a);
                    }
                    \uncover<6->{
                        \node[rectangle, scale=0.7, red] at (2.5, 1.0)  {$0$};
                    }                  
                \end{tikzpicture}

            \end{figure}

        \column{0.6\textwidth}
            \begin{outline}
                \renewcommand{\outlineii}{enumerate}
                \1 Árvore da função: $f(x,y) \defeq \overline{x + y}$
               
                \vspace{1em}
               
                \uncover<2->{\1 Para encontrar $f(0,1)$:}
                    \uncover<3->{\2 \textcolor<2>{red}{inicia-se pela raiz}}
                    \uncover<4->{\2 \textcolor<3>{red}{como $x$ é $0$, segue-se pela linha pontilhada}}
                    \uncover<5->{\2 \textcolor<4>{red}{como $y$ é $1$, segue-se pela linha sólida}}
                    \uncover<6->{\2 \textcolor<5>{red}{chega-se à folha $0$; logo $f(0,1) = 0$}}
            \end{outline}
    
    \end{columns}
            
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Semelhanças com tabelas-verdade}

    \begin{outline}
        \1 Árvores de Decisão Binárias são semelhantes às tabelas-verdade em relação ao tamanho
            \2[-] se $f$ depender de $n$ variáveis booleanas, a árvore correspondente terá pelo menos $2^{n+1}-1$ nós (contra as $2^n$ linhas da tabela verdade)
        
        \vspace{1em}
        
        \1 Mas muitas vezes elas contêm redundâncias que podem ser exploradas
    \end{outline}      

    \setlength{\fboxsep}{-5pt}
    \setlength{\parfillskip}{-5pt plus 0em}
    \ovalbox{\begin{quotation}
        \justifying
        \noindent\scriptsize
        A exploração de redundâncias em Árvores de Decisão Binárias faz com que deixem de ser árvores e se tornem grafos. Assim, passam a ser chamados de Diagramas de Decisão Binários (BDDs).
    \end{quotation}}    
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Remoção de nós terminais duplicados}

    \begin{figure}

        \begin{tikzpicture}
            [scale=0.9,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (12,6);
          
            % Leftmost graph
            \node (x) at (3.0, 5.0)  {$x$};
            \node (y1) at (1.5, 3.0)  {$y$};
            \node (y2) at (4.5, 3.0)  {$y$};
            \node[rectangle, scale=0.7] (1) at (0.5, 1.0) {$1$};
            \node[rectangle, scale=0.7] (0a) at (2.5, 1.0) {$0$};
            \node[rectangle, scale=0.7] (0b) at (3.5, 1.0) {$0$};
            \node[rectangle, scale=0.7] (0c) at (5.5, 1.0) {$0$};

            \draw[dashed, thick] (x) -- (y1);
            \draw[thick] (x) -- (y2);
            \draw[dashed, thick] (y1) -- (1);
            \draw[thick] (y1) -- (0a);
            \draw[dashed, thick] (y2) -- (0b);
            \draw[thick] (y2) -- (0c);

            \uncover<2->{
                \node[rectangle, scale=0.7, blue] (0a) at (2.5, 1.0) {$0$};
                \node[rectangle, scale=0.7, red] (0b) at (3.5, 1.0) {$0$};
                \node[rectangle, scale=0.7, red] (0c) at (5.5, 1.0) {$0$};

                \draw[dashed, thick, blue] (y2) -- (0b);
                \draw[thick, blue] (y2) -- (0c);
            }
            
            \uncover<3->{
                % Arrow with text
                \node[fill=white, single arrow, draw=black] at (6.5,4.0) {\scriptsize Simplificação C1};
                
                % Rightmost graph
                \node (x_) at (10.0, 5.0)  {$x$};
                \node (y1_) at (8.5, 3.0)  {$y$};
                \node (y2_) at (11.5, 3.0)  {$y$};
                \node[rectangle, scale=0.7] (1_) at (7.5, 1.0) {$1$};
                \node[rectangle, scale=0.7, blue] (0_) at (9.5, 1.0) {$0$};

                \draw[dashed, thick] (x_) -- (y1_);
                \draw[thick] (x_) -- (y2_);
                \draw[dashed, thick] (y1_) -- (1_);
                \draw[thick] (y1_) -- (0_);
                \draw[bend left, thick, blue] (y2_) to (0_);
                \draw[bend right, dashed, thick, blue] (y2_) to (0_);
            }
        \end{tikzpicture}

    \end{figure}

    \begin{quotation}
    \noindent\footnotesize\justifying
        Se um DDB contém mais de um nó terminal $0$, redirecionam-se todas as arestas que apontam para tais nós para apenas um deles. Repete-se o mesmo processo para os nós terminais com $1$
    \end{quotation}    
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Remoção de testes redundantes}

    \begin{figure}

        \begin{tikzpicture}
            [scale=0.9,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (12,6);
          
            % Leftmost graph
            \node (x) at (3.0, 5.0)  {$x$};
            \node (y1) at (1.5, 3.0)  {$y$};
            \node (y2) at (4.5, 3.0)  {$y$};
            \node[rectangle, scale=0.7] (1) at (0.5, 1.0) {$1$};
            \node[rectangle, scale=0.7] (0) at (2.5, 1.0) {$0$};

            \draw[dashed, thick] (x) -- (y1);
            \draw[thick] (x) -- (y2);
            \draw[dashed, thick] (y1) -- (1);
            \draw[thick] (y1) -- (0);
            \draw[bend left, thick] (y2) to (0);
            \draw[bend right, dashed, thick] (y2) to (0);
            
            \uncover<2->{
                \node[red] (y2) at (4.5, 3.0)  {$y$};
                \node[rectangle, scale=0.7, blue] (0) at (2.5, 1.0) {$0$};
                
                \draw[thick, blue] (x) -- (y2);
                \draw[bend left, thick, red] (y2) to (0);
                \draw[bend right, dashed, thick, red] (y2) to (0);
            }
            
            \uncover<3->{
                % Arrow with text
                \node[fill=white, single arrow, draw=black] at (6.5,4.0) {\scriptsize Simplificação C2};
                
                % Rightmost graph
                \node (x_) at (10.0, 5.0)  {$x$};
                \node (y1_) at (8.5, 3.0)  {$y$};
                \node[rectangle, scale=0.7] (1_) at (7.5, 1.0) {$1$};
                \node[rectangle, scale=0.7, blue] (0_) at (9.5, 1.0) {$0$};

                \draw[dashed, thick] (x_) -- (y1_);
                \draw[thick, blue] (x_) -- (0_);
                \draw[dashed, thick] (y1_) -- (1_);
                \draw[thick] (y1_) -- (0_);
            }
        \end{tikzpicture}

    \end{figure}
    
    \begin{quotation}
    \noindent\footnotesize\justifying
        Se ambas as arestas de um nó $n$ apontam para o mesmo nó $m$, elimina-se o nó $n$, enviando todas as arestas que nele chegavam para $m$.
    \end{quotation}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Remoção de nós não-terminais duplicados}

    \begin{figure}

        \begin{tikzpicture}
            [scale=0.8,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (12,6);
          
            % Leftmost graph
            \node (z) at (3.0, 5.5)  {$z$};
            \node (x1) at (1.5, 4.0)  {$x$};
            \node (x2) at (4.5, 4.0)  {$x$};
            
            \node (y1) at (0.6, 2.5)  {$y$};
            \node (y2) at (2.4, 2.5)  {$y$};
            \node (y3) at (3.6, 2.5)  {$y$};
            \node (y4) at (5.4, 2.5)  {$y$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.5) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.5) {$1$};

            \draw[dashed, thick] (z) -- (x1);
            \draw[thick] (z) -- (x2);
            \draw[dashed, thick] (x1) -- (y1);
            \draw[thick] (x1) -- (y2);
            \draw[dashed, thick] (x2) -- (y3);
            \draw[thick] (x2) -- (y4);
            
            \draw[dashed, thick] (y1) to (0);
            \draw[thick] (y1) to (1);
            \draw[dashed, thick] (y2) to (0);
            \draw[thick] (y2) to (1);
            \draw[dashed, thick] (y3) to (0);
            \draw[thick] (y3) to (1);
            \draw[thick] (y4) to (0);
            \draw[dashed, thick] (y4) to (1);
            
            \uncover<2->{
                \node[blue] (y2) at (2.4, 2.5)  {$y$};
                \node[red] (y3) at (3.6, 2.5)  {$y$};
                
                \draw[dashed, thick, blue] (x2) -- (y3);
                \draw[dashed, thick, blue] (y2) to (0);
                \draw[thick, blue] (y2) to (1);                
                \draw[dashed, thick, red] (y3) to (0);
                \draw[thick, red] (y3) to (1);
            }
            
            \uncover<3->{
                % Arrow with text
                \node[fill=white, single arrow, draw=black] at (6.7,4.0) {\scriptsize Simplificação C3};
                
                % Rightmost graph
                \node (z_) at (10.5, 5.5)  {$z$};
                \node (x1_) at (9.0, 4.0)  {$x$};
                \node (x2_) at (12.0, 4.0)  {$x$};
                
                \node (y1_) at (8.1, 2.5)  {$y$};
                \node[blue] (y2_) at (9.9, 2.5)  {$y$};
                \node (y4_) at (12.9, 2.5)  {$y$};
                
                \node[rectangle, scale=0.7] (0_) at (9.0, 0.5) {$0$};
                \node[rectangle, scale=0.7] (1_) at (12.0, 0.5) {$1$};

                \draw[dashed, thick] (z_) -- (x1_);
                \draw[thick] (z_) -- (x2_);
                \draw[dashed, thick] (x1_) -- (y1_);
                \draw[thick] (x1_) -- (y2_);
                \draw[dashed, thick, blue] (x2_) -- (y2_);
                \draw[thick] (x2_) -- (y4_);
                
                \draw[dashed, thick] (y1_) to (0_);
                \draw[thick] (y1_) to (1_);
                \draw[dashed, thick, blue] (y2_) to (0_);
                \draw[thick, blue] (y2_) to (1_);
                \draw[thick] (y4_) to (0_);
                \draw[dashed, thick] (y4_) to (1_);
            }
        \end{tikzpicture}

    \end{figure}
    
    \begin{quotation}
    \noindent\footnotesize\justifying
        Se dois nós distintos $n$ e $m$ são raizes de sub-DDBs idênticos, pode-se eliminar um deles redirecionando todas as arestas que chegam nele para o outro
    \end{quotation}
    
\end{frame}
%-------------------------------------------

%-------------------------------------------
\begin{frame}{Simplificações encadeadas}

    \begin{figure}

        \begin{tikzpicture}
            [scale=0.8,auto=left,
                every node/.style={circle, minimum height=4mm, draw=black, thick, align=center, text depth = 0pt, transform shape},
                every edge/.append style={draw=blue, thick}
            ]
            %\draw[help lines] (0,0) grid (12,6);
          
            % Leftmost graph
            \node (z) at (3.0, 5.5)  {$z$};
            \node (x1) at (1.5, 4.0)  {$x$};
            \node (x2) at (4.5, 4.0)  {$x$};
            
            \node (y1) at (0.6, 2.5)  {$y$};
            \node (y2) at (2.4, 2.5)  {$y$};
            \node (y4) at (5.4, 2.5)  {$y$};
            
            \node[rectangle, scale=0.7] (0) at (1.5, 0.5) {$0$};
            \node[rectangle, scale=0.7] (1) at (4.5, 0.5) {$1$};

            \draw[dashed, thick] (z) -- (x1);
            \draw[thick] (z) -- (x2);
            \draw[dashed, thick] (x1) -- (y1);
            \draw[thick] (x1) -- (y2);
            \draw[dashed, thick] (x2) -- (y2);
            \draw[thick] (x2) -- (y4);
            
            \draw[dashed, thick] (y1) to (0);
            \draw[thick] (y1) to (1);
            \draw[dashed, thick] (y2) to (0);
            \draw[thick] (y2) to (1);
            \draw[thick] (y4) to (0);
            \draw[dashed, thick] (y4) to (1);
            
            \uncover<2->{
                \node[red] (y1) at (0.6, 2.5)  {$y$};
                \node[blue] (y2) at (2.4, 2.5)  {$y$};
                
                \draw[dashed, thick, blue] (x1) -- (y1);
                \draw[dashed, thick, red] (y1) to (0);
                \draw[thick, red] (y1) to (1);
            }
            
            \uncover<3->{
                \node[red] (x1) at (1.5, 4.0)  {$x$};
                \draw[dashed, thick, blue] (z) -- (x1);
                \draw[dashed, thick, red] (x1) -- (y1);
                \draw[thick, red] (x1) -- (y2);
            }

            \uncover<4->{
                % Arrow with text
                \node[fill=white, single arrow, draw=black] at (6.7,4.0) {\small C3 + C2};
                
                % Rightmost graph
                \node (z_) at (9.0, 5.5)  {$z$};
                \node (x2_) at (10.5, 4.0)  {$x$};
                
                \node[blue] (y2_) at (8.4, 2.5)  {$y$};
                \node (y4_) at (11.4, 2.5)  {$y$};
                
                \node[rectangle, scale=0.7] (0_) at (7.5, 0.5) {$0$};
                \node[rectangle, scale=0.7] (1_) at (10.5, 0.5) {$1$};

                \draw[dashed, thick, blue] (z_) -- (y2_);
                \draw[thick] (z_) -- (x2_);
                \draw[dashed, thick] (x2_) -- (y2_);
                \draw[thick] (x2_) -- (y4_);
                
                \draw[dashed, thick] (y2_) to (0_);
                \draw[thick] (y2_) to (1_);
                \draw[thick] (y4_) to (0_);
                \draw[dashed, thick] (y4_) to (1_);
            }
        \end{tikzpicture}

    \end{figure}
    
    \begin{quotation}
    \noindent\footnotesize\justifying
        As simplificações C1, C2 e C3 podem ser encadeadas. Por exemplo, o DDB anterior ainda pode ser simplificado com a remoção de um dos nós $y$ duplicados (C3) e a remoção de um ponto de decisão $x$ redundante (C2)
    \end{quotation}
    
\end{frame}
%-------------------------------------------

\end{document}